package com.coreyd97.antivirus.server.engine;

import com.coreyd97.antivirus.common.report.FileFeatures;
import com.coreyd97.antivirus.common.report.MalwareEntry;
import com.coreyd97.antivirus.common.report.ScanReport;
import com.coreyd97.antivirus.common.taskscheduler.AnalysisTask;
import com.coreyd97.antivirus.common.taskscheduler.TrainTask;
import com.coreyd97.antivirus.common.utils.Utils;
import com.coreyd97.antivirus.server.DatabaseEngine;
import com.coreyd97.antivirus.server.taskscheduler.ExplainTask;
import com.coreyd97.c45.DataElement;
import com.coreyd97.c45.TreeNode;
import com.google.gson.Gson;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

import static com.coreyd97.antivirus.server.engine.ImportStatsAnalysisModule.getFunctionID;

public class CombinedModule extends AnalysisModule {
    public static final String engineName = "Combined Scanner";

    private DatabaseEngine databaseEngine;

    private TreeNode importTree;
    private TreeNode ruleTree;

    public CombinedModule(AnalysisManager analysisManager) {
        super(engineName, false);
        this.databaseEngine = analysisManager.getDatabaseEngine();

        loadTrees();
    }

    private void loadTrees(){
        File importTreeFile = new File("./config/importRuleTree");
        File ruleTreeFile = new File("./config/yaraRuleTree");
        try {
            importTree = new Gson().fromJson(new FileReader(importTreeFile), TreeNode.class);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            //TODO handle missing decision tree.
            //TODO Add ability for server to report errors to client w/r processing reports.
        }

        try {
            ruleTree = new Gson().fromJson(new FileReader(ruleTreeFile), TreeNode.class);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            //TODO handle missing decision tree.
            //TODO Add ability for server to report errors to client w/r processing reports.
        }
    }

    @Override
    public TrainTask train(Utils.FileStatus fileStatus, File[] files) {
        return null;
    }

    @Override
    public AnalysisTask processReport(ScanReport scanReport) {
        AnalysisTask analysisTask = new CombinedAnalysisTask("Combined Scan Analysis", scanReport);
        return analysisTask;
    }

    @Override
    public ExplainTask explain(ScanReport scanReport) {
        return null;
    }

    private class CombinedAnalysisTask extends AnalysisTask {

        protected CombinedAnalysisTask(String taskName, ScanReport report) {
            super(taskName, report);
        }

        @Override
        public void processFile(FileFeatures fileFeatures) throws SQLException {
            Connection connection = databaseEngine.getConnection(this);
            String hashTypeString = fileFeatures.featureMap.get(FileFeatures.Feature.HASH_TYPE);
            Utils.HashType hashType = Utils.HashType.valueOf(hashTypeString);
            String hash = fileFeatures.featureMap.get(FileFeatures.Feature.valueOf(hashType.toString()));
            if (DatabaseEngine.isSampleMalicious(connection, hashType, hash)) {
                resultsReport.addMalware(new MalwareEntry(fileFeatures.filePath, 100, "Matched existing hash"));
                databaseEngine.releaseConnection(connection);
                return;
            }
            databaseEngine.releaseConnection(connection);

            //Hash analysis didn't give anything, try other methods.
            if(fileFeatures.mapOfLists != null) {
                connection = databaseEngine.getConnection(this);
                HashSet<String> functionIDs = new HashSet<>();
                for (String dllName : fileFeatures.mapOfLists.keySet()) {
                    try {
                        int dllID = ImportStatsAnalysisModule.getDLLID(connection, dllName);
                        for (String functionName : fileFeatures.mapOfLists.get(dllName)) {
                            try {
                                int functionID = getFunctionID(connection, dllID, functionName);
                                if(functionID != -1)
                                    functionIDs.add(String.valueOf(functionID));
                            } catch (SQLException ignored) {
                            }
                        }
                    } catch (SQLException e) {
                        e.printStackTrace();
                    }
                }
                databaseEngine.releaseConnection(connection);

                DataElement element = new DataElement(null, null, functionIDs);
                if (importTree.classify(element).equalsIgnoreCase("MALWARE")) {
                    resultsReport.addMalware(new MalwareEntry(fileFeatures.filePath, 0, "The imports used were similar to those used by malware."));
                    return;
                }
            }

            //Check rules
            if(fileFeatures.featureList != null){
                HashMap<String, String> features = new HashMap<>();
                HashSet<String> rules = new HashSet<>();
                if(fileFeatures.featureList != null) {
                    rules.addAll((ArrayList<String>) fileFeatures.featureList);
                }

                fileFeatures.featureMap.forEach((feature, value) -> {
                    features.put(feature.toString(), value);
                });

                DataElement element = new DataElement(null, features, rules);
                if(ruleTree.classify(element).equalsIgnoreCase("MALWARE")) {
                    resultsReport.addMalware(new MalwareEntry(fileFeatures.filePath, -0, "Matched yararules similar to those matched by malware."));
                }
            }
        }
    }
}