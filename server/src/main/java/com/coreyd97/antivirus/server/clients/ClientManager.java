package com.coreyd97.antivirus.server.clients;

import com.coreyd97.antivirus.common.network.ServerConnectionHandler;
import com.coreyd97.antivirus.common.stats.StatProvider;
import com.coreyd97.antivirus.common.taskscheduler.TaskScheduler;
import com.coreyd97.antivirus.server.taskscheduler.BanClientTask;
import com.coreyd97.antivirus.server.taskscheduler.GetBannedClients;
import com.coreyd97.antivirus.server.taskscheduler.UnbanClientTask;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.net.Inet4Address;
import java.util.ArrayList;
import java.util.HashMap;

public class ClientManager implements StatProvider {

    private final HashMap<Inet4Address, Client> clients;
    private final ServerConnectionHandler firewallConnection;
    private final TaskScheduler taskScheduler;
    private final ArrayList<IClientListener> clientListeners;

    public ClientManager(ServerConnectionHandler firewallConnection, TaskScheduler taskScheduler){
        clients = new HashMap<>();
        this.firewallConnection = firewallConnection;
        this.taskScheduler = taskScheduler;
        this.clientListeners = new ArrayList<>();

        GetBannedClients bannedClientsTask = new GetBannedClients(firewallConnection);
        bannedClientsTask.setCallback(() -> {
            ArrayList<Inet4Address> bannedClients = bannedClientsTask.getResult();
            if(bannedClients != null){
                for (Inet4Address bannedClient : bannedClients) {
                    Client client = addNewClient(bannedClient);
                    client.status = Client.Status.BANNED;
                }
            }
        });
        this.taskScheduler.execute(bannedClientsTask);
    }

    public ArrayList<Client> getClients(){
        return new ArrayList<Client>(this.clients.values());
    }

    public boolean clientExists(Inet4Address address){
        return clients.containsKey(address);
    }

    public Client addNewClient(Inet4Address address){
        if(!clientExists(address)) {
            Client client = new Client(address);
            clients.put(address, client);
            synchronized (this.clientListeners) {
                for (IClientListener clientListener : this.clientListeners) {
                    clientListener.onClientConnected(client);
                }
            }
            return client;
        }else{
            return this.clients.get(address);
        }
    }

    public void banClient(Inet4Address address){
        Client client = clients.get(address);
        if(client == null){
            client = addNewClient(address);
        }

        if(client.getStatus() == Client.Status.OK) {
            BanClientTask banTask = new BanClientTask(this.firewallConnection, client.address);
            Client finalClient = client;
            banTask.setCallback(() -> {
                if (banTask.getResult()) {
                    finalClient.status = Client.Status.BANNED;

                    synchronized (this.clientListeners) {
                        for (IClientListener clientListener : this.clientListeners) {
                            clientListener.onClientBanned(finalClient);
                        }
                    }
                } else {
                    //Not Banned, flag for manual ban?
                }
            });
            taskScheduler.execute(banTask);
        }
    }

    public void unbanClient(Inet4Address address){
        Client client = clients.get(address);
        if(client == null){
            client = addNewClient(address);
        }
        if(client.getStatus() == Client.Status.BANNED) {

            UnbanClientTask banTask = new UnbanClientTask(this.firewallConnection, client.address);
            Client finalClient = client;
            banTask.setCallback(() -> {
                if (banTask.getResult()) {
                    finalClient.status = Client.Status.OK;
                    synchronized (this.clientListeners) {
                        for (IClientListener clientListener : this.clientListeners) {
                            clientListener.onClientUnbanned(finalClient);
                        }
                    }
                } else {
                    //Not unbanned, flag for manual unban?
                }
            });
            taskScheduler.execute(banTask);
        }
    }

    public void addClientListener(IClientListener clientListener){
        this.clientListeners.add(clientListener);
    }

    public void removeClientListener(IClientListener clientListener){
        this.clientListeners.remove(clientListener);
    }

    JPanel statPanel;
    JLabel lblActiveCount, lblBannedCount;

    @Override
    public JPanel getStatPanel() {
        if(statPanel == null){
            statPanel = new JPanel(new GridLayout(0,2));
            TitledBorder border = BorderFactory.createTitledBorder("Clients");
            border.setTitleColor(Color.BLUE);
            statPanel.setBorder(border);

            lblActiveCount = new JLabel();
            lblBannedCount = new JLabel();

            statPanel.add(lblActiveCount);
            statPanel.add(lblBannedCount);
        }

        int activeClients = 0, bannedClients = 0;
        for (Client client : this.clients.values()) {
            switch (client.status) {
                case OK: activeClients++; break;
                case BANNED: bannedClients++; break;
            }
        }

        lblActiveCount.setText("Active Clients: " + activeClients);
        lblBannedCount.setText("Banned Clients: " + bannedClients);

        return statPanel;
    }
}
