package com.coreyd97.antivirus.server;

import com.coreyd97.antivirus.common.utils.Utils;
import com.coreyd97.antivirus.server.ui.StatProvider;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

/**
 * The type Database engine.
 */
public class DatabaseEngine implements StatProvider {
    private static DatabaseEngine instance;
    private static String sampleSelect = "SELECT ID FROM Samples WHERE MD5=? LIMIT 1";
    private static String sampleInsert = "INSERT INTO Samples VALUES(NULL, ?, ?, ?, ?, ?, ?)";
    public static String trainedUpdateClean = "UPDATE Training SET CleanSamples=CleanSamples+? WHERE Module=?";
    public static String trainedUpdateMalware = "UPDATE Training SET MalwareSamples=MalwareSamples+? WHERE Module=?";
    private HashMap<Connection, Object> connections;

    public static DatabaseEngine getInstance() {
        if(instance == null) try {
            instance = new DatabaseEngine();
        } catch (SQLException | ClassNotFoundException e) {
            System.err.println("Failed to establish database connection.\n" + e.getMessage());
            System.exit(0);
        }
        return instance;
    }

    public DatabaseEngine() throws SQLException, ClassNotFoundException {
        this(10);
    }

    public DatabaseEngine(int connections) throws SQLException, ClassNotFoundException {
        Class.forName("org.h2.Driver");
        this.connections = new HashMap<>();
        for (int i = 0; i < connections; i++) {
            this.connections.put(DriverManager.getConnection("jdbc:h2:./config/MalwareDatabase;AUTO_SERVER=TRUE;MULTI_THREADED=TRUE", "sa", ""), null);
        }
        createTables();
    }

    public Connection getConnection(Object owner) {
        synchronized (this.connections) {
            if (!this.connections.values().contains(null)) { //If all connections occupied
                try {
                    this.connections.wait();
                } catch (InterruptedException e) {
                }
            }
            for (Connection connection : this.connections.keySet()) {
                if (this.connections.get(connection) == null) {
                    this.connections.put(connection, owner);
                    return connection;
                }
            }
            return null;
        }
    }

    public void releaseConnection(Connection connection) {
        synchronized (this.connections) {
            this.connections.put(connection, null);
            this.connections.notifyAll();
        }
    }

    private void createTables() throws SQLException, ClassNotFoundException {
        Connection connection = getConnection(this);
        Statement statement = connection.createStatement();
        statement.executeUpdate("CREATE TABLE IF NOT EXISTS MimeTypes(ID INT AUTO_INCREMENT PRIMARY KEY, Mime VARCHAR(128))");
        statement.executeUpdate("CREATE TABLE IF NOT EXISTS Samples(ID INT AUTO_INCREMENT PRIMARY KEY, SampleName VARCHAR (255), MD5 CHAR(32), SHA1 CHAR(40), KbSize INT, Mime INT, Malware BOOLEAN DEFAULT FALSE NOT NULL, FOREIGN KEY (Mime) REFERENCES MimeTypes(ID))");
        statement.executeUpdate("CREATE TABLE IF NOT EXISTS Modules(ID int AUTO_INCREMENT, Name VARCHAR(128))");
        statement.executeUpdate("CREATE TABLE IF NOT EXISTS Training(ModuleID int, SampleID int, PRIMARY KEY(ModuleID, SampleID), FOREIGN KEY (SampleID) REFERENCES Samples(ID), FOREIGN KEY (ModuleID) REFERENCES Modules(ID))");
        statement.close();
        releaseConnection(connection);
    }

    public void shutdown() {
        try {
            for (Connection connection : this.connections.keySet()) {
                this.connections.put(connection, true);
                connection.close();
            }
        }catch (SQLException e){}
    }

    public int registerModule(Connection connection, String moduleName) throws SQLException {
        String query = "SELECT ID FROM Modules WHERE Name=?";
        PreparedStatement stmt = connection.prepareStatement(query);
        try {
            stmt.setString(1, moduleName);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1);
            } else {
                String insert = "INSERT INTO MODULES VALUES (NULL, ?)";
                stmt = connection.prepareStatement(insert, Statement.RETURN_GENERATED_KEYS);
                stmt.setString(1, moduleName);
                stmt.executeUpdate();
                rs = stmt.getGeneratedKeys();
                if (rs.next()) {
                    return rs.getInt(1);
                } else {
                    //Could not add to the db
                    throw new SQLException("Could not add the module to the database!");
                }
            }
        } finally {
            stmt.close();
        }
    }

    public int trimSamples(Connection connection) {
        try {
            PreparedStatement statement = connection.prepareStatement("DELETE FROM SAMPLES " +
                    "WHERE SAMPLES.ID NOT IN (SELECT SAMPLEID FROM FUNCTIONUSAGE GROUP BY SAMPLEID) " +
                    "   AND SAMPLES.ID NOT IN (SELECT SAMPLEID FROM YARAMATCHES GROUP BY SAMPLEID) AND NOT SAMPLES.MALWARE");
            return statement.executeUpdate();
        }catch (SQLException ignored){}
        return 0;
    }

    public boolean containsSample(Connection connection, int fileSize, Utils.HashType hashType, String hash) throws SQLException {
        PreparedStatement stmt;
        switch (hashType) {
            case MD5: stmt = connection.prepareStatement("SELECT SampleID FROM Samples WHERE MD5=? AND KbSize=? LIMIT 1");
                break;
            case SHA1: stmt = connection.prepareStatement("SELECT SampleID FROM Samples WHERE SHA1=? AND KbSize=? LIMIT 1");
                break;
            default: return false;
        }
        stmt.setString(1, hash);
        stmt.setInt(2, fileSize);
        ResultSet results = stmt.executeQuery();
        return results.next();
    }

    public boolean containsSample(Connection connection, File file) throws IOException, SQLException {
        return getSampleID(connection, file) == -1;
    }

    public int getSampleID(Connection connection, File file) throws SQLException, IOException {
        String md5 = "";
        try{
            md5 = Utils.fileChecksum(MessageDigest.getInstance("MD5"), file);
        }catch (NoSuchAlgorithmException e){e.printStackTrace();}
        return getSampleID(connection, md5);
    }

    public int getSampleID(Connection connection, String md5) throws SQLException {
        connection.setAutoCommit(false);
        PreparedStatement stmt = connection.prepareStatement(sampleSelect);
        try{
            stmt.setString(1, md5);
            ResultSet results = stmt.executeQuery();
            if(results.next()){
                return results.getInt(1);
            }else{
                return -1;
            }
        }finally {
            stmt.close();
            connection.setAutoCommit(true);
        }
    }

    public int getMimeTypeID(Connection connection, String type) throws SQLException {
        PreparedStatement stmt = connection.prepareStatement("SELECT ID FROM MimeTypes WHERE Mime=? LIMIT 1");
        try {
            stmt.setString(1, type);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1);
            } else {
                stmt = connection.prepareStatement("INSERT INTO MimeTypes VALUES (NULL, ?)", Statement.RETURN_GENERATED_KEYS);
                stmt.setString(1, type);
                stmt.executeUpdate();
                rs = stmt.getGeneratedKeys();
                if (rs.next()) {
                    return rs.getInt(1);
                } else {
                    return -1; //This should never be reached
                }
            }
        } finally {
            stmt.close();
        }
    }

    public ArrayList<String> getMimeTypes(Connection connection) throws SQLException {
        ArrayList<String> mimeTypes = new ArrayList<>();
        Statement stmt = connection.createStatement();
        try {
            ResultSet rs = stmt.executeQuery("SELECT MIME FROM MIMETYPES");
            while (rs.next()) {
                String mime = rs.getString(1);
                mimeTypes.add(mime);
            }
            return mimeTypes;
        } finally {
            stmt.close();
        }
    }

    //Add a sample to the database and return the sampleid.
    public int addSampleIfNotExists(Connection connection, File file, boolean isMalware) throws SQLException, IOException {
        String filename = file.getName();
        String md5 = "", sha1 = "";
        try {
            md5 = Utils.fileChecksum(MessageDigest.getInstance("MD5"), file);
            sha1 = Utils.fileChecksum(MessageDigest.getInstance("SHA1"), file);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        int filesize = Math.round(file.length() / 1024);
        int sampleID = getSampleID(connection, md5);
        if(sampleID != -1) return sampleID;
        else {
            int mimeTypeID = getMimeTypeID(connection, Files.probeContentType(file.toPath()));
            return addSampleIfNotExists(connection, filename, md5, sha1, filesize, mimeTypeID, isMalware);
        }
    }

    public int addSampleIfNotExists(Connection connection, String fileName, String md5, String sha1, int filesize, int mimeTypeID, boolean isMalware) throws SQLException{
        PreparedStatement stmt = connection.prepareStatement(sampleInsert, Statement.RETURN_GENERATED_KEYS);
        try {
            stmt.setString(1, fileName);
            stmt.setString(2, md5);
            stmt.setString(3, sha1);
            stmt.setInt(4, filesize);
            stmt.setInt(5, mimeTypeID);
            stmt.setBoolean(6, isMalware);
            stmt.executeUpdate();
            ResultSet results = stmt.getGeneratedKeys();
            if (results.next()) {
                return results.getInt(1);
            } else {
                throw new SQLException("Sample was not added to database!");
            }
        }finally {
            stmt.close();
        }
    }

    public String getTrainedCountManualQuery(String module, int count, Utils.FileStatus fileStatus) throws SQLException {
        String stmt = (fileStatus == Utils.FileStatus.CLEAN) ? trainedUpdateClean : trainedUpdateMalware;
        stmt = stmt.replaceFirst("\\?", String.valueOf(count));
        stmt = stmt.replaceFirst("\\?", module);
        return stmt;
    }

    public Integer getModuleID(Connection connection, String moduleName) throws SQLException {
        String query = "SELECT ID FROM MODULES WHERE NAME=? LIMIT 1";
        PreparedStatement stmt = connection.prepareStatement(query);
        try {
            stmt.setString(1, moduleName);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            else return null;
        } finally {
            stmt.close();
        }
    }

    public boolean isModuleTrained(Connection connection, String engineName, int sampleID) throws SQLException {
        Integer moduleID = getModuleID(connection, engineName);
        if(moduleID == null) throw new IllegalArgumentException("Module " + engineName + " is not listed in the database.");
        return isModuleTrained(connection, moduleID, sampleID);
    }

    public boolean isModuleTrained(Connection connection, int moduleID, int sampleID) throws SQLException {
        String isModuleTrainedOnSample = "SELECT EXISTS(SELECT TRUE FROM TRAINING WHERE SAMPLEID=? AND MODULEID=?)";
        PreparedStatement stmt = connection.prepareStatement(isModuleTrainedOnSample);
        try {
            stmt.setInt(1, sampleID);
            stmt.setInt(2, moduleID);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return rs.getBoolean(1);
            }
            return false;
        } finally {
            stmt.close();
        }
    }

    public void markSampleTrained(Connection connection, int moduleID, int sampleID) throws SQLException {
        String insert = "INSERT INTO Training VALUES (?, ?)";
        PreparedStatement stmt = connection.prepareStatement(insert);
        try {
            stmt.setInt(1, moduleID);
            stmt.setInt(2, sampleID);
            stmt.executeUpdate();
        } finally {
            stmt.close();
        }
    }

    public Map<Boolean, Integer> getModuleTrainedCount(Connection connection, int moduleID){
        String getCount = "SELECT MALWARE, COUNT(1) " +
                "FROM (TRAINING LEFT JOIN (SELECT ID, MALWARE FROM SAMPLES) AS S ON TRAINING.SAMPLEID = S.ID)" +
                "WHERE MODULEID=? GROUP BY MALWARE";
        PreparedStatement stmt = null;
        HashMap<Boolean, Integer> count = new HashMap<>();
        try {
            stmt = connection.prepareStatement(getCount);
            count.put(true, 0);
            count.put(false, 0);
            stmt.setInt(1, moduleID);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                if (rs.getBoolean(1)) {
                    count.put(true, rs.getInt(2));
                } else {
                    count.put(false, rs.getInt(2));
                }
            }
        }catch (SQLException e){
            count.put(true, 0);
            count.put(false, 0);
        } finally {
            if(stmt != null) {
                try {
                    stmt.close();
                }catch (SQLException ignored){}
            }
        }
        return count;
    }

    @Override
    public JPanel getStatPanel() {
        JPanel panel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.weightx = gbc.weighty = 1.0;
        gbc.fill = GridBagConstraints.BOTH;
        TitledBorder border = BorderFactory.createTitledBorder("Database");
//        border.setTitleJustification(TitledBorder.CENTER);
        border.setTitleColor(Color.BLUE);
        panel.setBorder(border);
        int malwareSamples = 0;
        int cleanSamples = 0;
        Connection connection = getConnection(this);
        String selectSampleCounts = "SELECT MALWARE, COUNT(MALWARE) FROM SAMPLES GROUP BY MALWARE";
        PreparedStatement stmt = null;
        try {
            stmt = connection.prepareStatement(selectSampleCounts);
            ResultSet rs = stmt.executeQuery();
            while(rs.next()){
                if(rs.getBoolean(1)){
                    malwareSamples = rs.getInt(2);
                }else{
                    cleanSamples = rs.getInt(2);
                }
            }
            int cleanPercent = (int) Math.round((((double) cleanSamples)/(cleanSamples+malwareSamples))*100);
            int malwarePercent = (int) Math.round((((double) malwareSamples)/(cleanSamples+malwareSamples))*100);
            panel.add(new JLabel(String.format("Clean Samples: %d (%d%%)", cleanSamples, cleanPercent)), gbc);
            gbc.gridy++;
            panel.add(new JLabel(String.format("Malicious Samples: %d (%d%%)", malwareSamples, malwarePercent)), gbc);
        } catch (SQLException ignored) {
        } finally {
            if(stmt != null){
                try{
                    stmt.close();
                }catch (SQLException ignored){}
            }
        }

        releaseConnection(connection);
        return panel;
    }
}
