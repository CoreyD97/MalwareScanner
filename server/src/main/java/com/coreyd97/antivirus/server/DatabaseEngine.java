package com.coreyd97.antivirus.server;

import com.coreyd97.antivirus.common.utils.Utils;
import com.coreyd97.antivirus.common.stats.StatProvider;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

/**
 * The type Database engine.
 */
public class DatabaseEngine implements StatProvider {
    private HashMap<Connection, Object> connections;

    public DatabaseEngine() throws SQLException, ClassNotFoundException {
        this(10);
    }

    public DatabaseEngine(int connections) throws SQLException, ClassNotFoundException {
        Class.forName("org.h2.Driver");
        this.connections = new HashMap<>();
        for (int i = 0; i < connections; i++) {
            this.connections.put(DriverManager.getConnection("jdbc:h2:./config/MalwareDatabase;AUTO_SERVER=TRUE;MULTI_THREADED=TRUE", "sa", ""), null);
        }
        createTables();
    }

    public Connection getConnection(Object owner) {
        synchronized (this.connections) {
            if (!this.connections.values().contains(null)) { //If all connections occupied
                try {
                    this.connections.wait();
                } catch (InterruptedException e) {
                }
            }
            for (Connection connection : this.connections.keySet()) {
                if (this.connections.get(connection) == null) {
                    this.connections.put(connection, owner);
                    return connection;
                }
            }
            return null;
        }
    }

    public void releaseConnection(Connection connection) {
        synchronized (this.connections) {
            this.connections.put(connection, null);
            this.connections.notifyAll();
        }
    }

    private void createTables() throws SQLException, ClassNotFoundException {
        Connection connection = getConnection(this);
        Statement statement = connection.createStatement();
        statement.executeUpdate("CREATE TABLE IF NOT EXISTS MimeTypes(ID INT AUTO_INCREMENT PRIMARY KEY, Mime VARCHAR(128))");
        statement.executeUpdate("CREATE TABLE IF NOT EXISTS Samples(ID INT AUTO_INCREMENT PRIMARY KEY, SampleName VARCHAR (255), MD5 CHAR(32), SHA1 CHAR(40), KbSize INT, Mime INT, Malware BOOLEAN DEFAULT FALSE NOT NULL, FOREIGN KEY (Mime) REFERENCES MimeTypes(ID))");
        statement.executeUpdate("CREATE TABLE IF NOT EXISTS Modules(ID int AUTO_INCREMENT, Name VARCHAR(128))");
        statement.executeUpdate("CREATE TABLE IF NOT EXISTS Training(ModuleID int, SampleID int, PRIMARY KEY(ModuleID, SampleID), FOREIGN KEY (SampleID) REFERENCES Samples(ID), FOREIGN KEY (ModuleID) REFERENCES Modules(ID))");
        statement.close();
        releaseConnection(connection);
    }

    public void shutdown() {
        try {
            for (Connection connection : this.connections.keySet()) {
                this.connections.put(connection, true);
                connection.close();
            }
        }catch (SQLException e){}
    }

    public static int registerModule(Connection connection, String moduleName) throws SQLException {
        String query = "SELECT ID FROM Modules WHERE Name=?";
        PreparedStatement stmt = connection.prepareStatement(query);
        try {
            stmt.setString(1, moduleName);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1);
            } else {
                String insert = "INSERT INTO MODULES VALUES (NULL, ?)";
                stmt = connection.prepareStatement(insert, Statement.RETURN_GENERATED_KEYS);
                stmt.setString(1, moduleName);
                stmt.executeUpdate();
                rs = stmt.getGeneratedKeys();
                if (rs.next()) {
                    return rs.getInt(1);
                } else {
                    //Could not add to the db
                    throw new SQLException("Could not add the module to the database!");
                }
            }
        } finally {
            stmt.close();
        }
    }

    public static int trimSamples(Connection connection) {
        try {
            PreparedStatement statement = connection.prepareStatement("DELETE FROM SAMPLES " +
                    "WHERE SAMPLES.ID NOT IN (SELECT SAMPLEID FROM FUNCTIONUSAGE GROUP BY SAMPLEID) " +
                    "   AND SAMPLES.ID NOT IN (SELECT SAMPLEID FROM YARAMATCHES GROUP BY SAMPLEID) AND NOT SAMPLES.MALWARE");
            return statement.executeUpdate();
        }catch (SQLException ignored){}
        return 0;
    }

    public static boolean containsSample(Connection connection, int fileSize, Utils.HashType hashType, String hash) throws SQLException {
        PreparedStatement stmt;
        switch (hashType) {
            case MD5: stmt = connection.prepareStatement("SELECT SampleID FROM Samples WHERE MD5=? AND KbSize=? LIMIT 1");
                break;
            case SHA1: stmt = connection.prepareStatement("SELECT SampleID FROM Samples WHERE SHA1=? AND KbSize=? LIMIT 1");
                break;
            default: return false;
        }
        stmt.setString(1, hash);
        stmt.setInt(2, fileSize);
        ResultSet results = stmt.executeQuery();
        return results.next();
    }

    public static boolean containsSample(Connection connection, File file) throws IOException, SQLException {
        return getSampleID(connection, file) == -1;
    }

    public static boolean isSampleMalicious(Connection connection, Utils.HashType hashType, String hash) throws SQLException {
        String query;
        switch (hashType){
            case SHA1: {
                query = "SELECT MALWARE FROM SAMPLES WHERE SHA1=? LIMIT 1"; break;
            }
            case MD5: {
                query = "SELECT MALWARE FROM SAMPLES WHERE MD5=? LIMIT 1"; break;
            }
            default: return false;
        }
        if(connection == null) return false;
        PreparedStatement stmt = connection.prepareStatement(query);
        stmt.setString(1, hash);
        ResultSet rs = stmt.executeQuery();
        if(rs.next()){
            return rs.getBoolean(1);
        }else{
            return false;
        }
    }

    public static int getSampleID(Connection connection, File file) throws SQLException, IOException {
        String md5 = "";
        try{
            md5 = Utils.fileChecksum(MessageDigest.getInstance("MD5"), file);
        }catch (NoSuchAlgorithmException e){e.printStackTrace();}
        return getSampleID(connection, md5);
    }

    public static int getSampleID(Connection connection, String md5) throws SQLException {
        connection.setAutoCommit(false);
        String sampleSelect = "SELECT ID FROM Samples WHERE MD5=? LIMIT 1";
        PreparedStatement stmt = connection.prepareStatement(sampleSelect);
        try{
            stmt.setString(1, md5);
            ResultSet results = stmt.executeQuery();
            if(results.next()){
                return results.getInt(1);
            }else{
                return -1;
            }
        }finally {
            stmt.close();
            connection.setAutoCommit(true);
        }
    }

    public static int getMimeTypeID(Connection connection, String type) throws SQLException {
        PreparedStatement stmt = connection.prepareStatement("SELECT ID FROM MimeTypes WHERE Mime=? LIMIT 1");
        try {
            stmt.setString(1, type);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return rs.getInt(1);
            } else {
                stmt = connection.prepareStatement("INSERT INTO MimeTypes VALUES (NULL, ?)", Statement.RETURN_GENERATED_KEYS);
                stmt.setString(1, type);
                stmt.executeUpdate();
                rs = stmt.getGeneratedKeys();
                if (rs.next()) {
                    return rs.getInt(1);
                } else {
                    return -1; //This should never be reached
                }
            }
        } finally {
            stmt.close();
        }
    }

    public static ArrayList<String> getMimeTypes(Connection connection) throws SQLException {
        ArrayList<String> mimeTypes = new ArrayList<>();
        Statement stmt = connection.createStatement();
        try {
            ResultSet rs = stmt.executeQuery("SELECT MIME FROM MIMETYPES");
            while (rs.next()) {
                String mime = rs.getString(1);
                mimeTypes.add(mime);
            }
            return mimeTypes;
        } finally {
            stmt.close();
        }
    }

    //Add a sample to the database and return the sampleid.
    public static int addSampleIfNotExists(Connection connection, File file, boolean isMalware) throws SQLException, IOException {
        String filename = file.getName();
        String md5 = "", sha1 = "";
        try {
            md5 = Utils.fileChecksum(MessageDigest.getInstance("MD5"), file);
            sha1 = Utils.fileChecksum(MessageDigest.getInstance("SHA1"), file);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        int filesize = Math.round(file.length() / 1024);
        int sampleID = getSampleID(connection, md5);
        if(sampleID != -1) return sampleID;
        else {
            int mimeTypeID = getMimeTypeID(connection, Files.probeContentType(file.toPath()));
            return addSampleIfNotExists(connection, filename, md5, sha1, filesize, mimeTypeID, isMalware);
        }
    }

    public static int addSampleIfNotExists(Connection connection, String fileName, String md5, String sha1, int filesize, int mimeTypeID, boolean isMalware) throws SQLException{
        String sampleInsert = "INSERT INTO Samples VALUES(NULL, ?, ?, ?, ?, ?, ?)";
        PreparedStatement stmt = connection.prepareStatement(sampleInsert, Statement.RETURN_GENERATED_KEYS);
        try {
            stmt.setString(1, fileName);
            stmt.setString(2, md5);
            stmt.setString(3, sha1);
            stmt.setInt(4, filesize);
            stmt.setInt(5, mimeTypeID);
            stmt.setBoolean(6, isMalware);
            stmt.executeUpdate();
            ResultSet results = stmt.getGeneratedKeys();
            if (results.next()) {
                return results.getInt(1);
            } else {
                throw new SQLException("Sample was not added to database!");
            }
        }finally {
            stmt.close();
        }
    }

    public static Integer getModuleID(Connection connection, String moduleName) throws SQLException {
        String query = "SELECT ID FROM MODULES WHERE NAME=? LIMIT 1";
        PreparedStatement stmt = connection.prepareStatement(query);
        try {
            stmt.setString(1, moduleName);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) return rs.getInt(1);
            else return null;
        } finally {
            stmt.close();
        }
    }

    public static boolean isModuleTrained(Connection connection, String engineName, int sampleID) throws SQLException {
        Integer moduleID = getModuleID(connection, engineName);
        if(moduleID == null) throw new IllegalArgumentException("Module " + engineName + " is not listed in the database.");
        return isModuleTrained(connection, moduleID, sampleID);
    }

    public static boolean isModuleTrained(Connection connection, int moduleID, int sampleID) throws SQLException {
        String isModuleTrainedOnSample = "SELECT EXISTS(SELECT TRUE FROM TRAINING WHERE SAMPLEID=? AND MODULEID=?)";
        PreparedStatement stmt = connection.prepareStatement(isModuleTrainedOnSample);
        try {
            stmt.setInt(1, sampleID);
            stmt.setInt(2, moduleID);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                return rs.getBoolean(1);
            }
            return false;
        } finally {
            stmt.close();
        }
    }

    public static void markSampleTrained(Connection connection, int moduleID, int sampleID) throws SQLException {
        String insert = "INSERT INTO Training VALUES (?, ?)";
        PreparedStatement stmt = connection.prepareStatement(insert);
        try {
            stmt.setInt(1, moduleID);
            stmt.setInt(2, sampleID);
            stmt.executeUpdate();
        } finally {
            stmt.close();
        }
    }

    public static Map<Boolean, Integer> getModuleTrainedCount(Connection connection, int moduleID){
        String getCount = "SELECT MALWARE, COUNT(1) " +
                "FROM (TRAINING LEFT JOIN (SELECT ID, MALWARE FROM SAMPLES) AS S ON TRAINING.SAMPLEID = S.ID)" +
                "WHERE MODULEID=? GROUP BY MALWARE";
        PreparedStatement stmt = null;
        HashMap<Boolean, Integer> count = new HashMap<>();
        try {
            stmt = connection.prepareStatement(getCount);
            count.put(true, 0);
            count.put(false, 0);
            stmt.setInt(1, moduleID);
            ResultSet rs = stmt.executeQuery();
            while (rs.next()) {
                if (rs.getBoolean(1)) {
                    count.put(true, rs.getInt(2));
                } else {
                    count.put(false, rs.getInt(2));
                }
            }
        }catch (SQLException e){
            count.put(true, 0);
            count.put(false, 0);
        } finally {
            if(stmt != null) {
                try {
                    stmt.close();
                }catch (SQLException ignored){}
            }
        }
        return count;
    }


    private JPanel statPanel;
    private JLabel cleanSamplesLabel, maliciousSamplesLabel, activeConnectionsLabel, availableConnectionsLabel;
    private int cleanCount, maliciousCount;

    @Override
    public JPanel getStatPanel() {
        if(statPanel == null) {
            statPanel = new JPanel(new GridLayout(0,2));
            GridBagConstraints gbc = new GridBagConstraints();
            gbc.fill = GridBagConstraints.BOTH;
            TitledBorder border = BorderFactory.createTitledBorder("Database");
            border.setTitleColor(Color.BLUE);
            statPanel.setBorder(border);

            cleanSamplesLabel = new JLabel();
            maliciousSamplesLabel = new JLabel();
            activeConnectionsLabel = new JLabel();
            availableConnectionsLabel = new JLabel();

            statPanel.add(cleanSamplesLabel);
            statPanel.add(maliciousSamplesLabel);
            statPanel.add(activeConnectionsLabel);
            statPanel.add(availableConnectionsLabel);


            Connection connection = getConnection(this);
            String selectSampleCounts = "SELECT MALWARE, COUNT(MALWARE) FROM SAMPLES GROUP BY MALWARE";
            PreparedStatement stmt = null;
            try {
                stmt = connection.prepareStatement(selectSampleCounts);
                ResultSet rs = stmt.executeQuery();
                while(rs.next()){
                    if(rs.getBoolean(1)){
                        maliciousCount = rs.getInt(2);
                    }else{
                        cleanCount = rs.getInt(2);
                    }
                }
            } catch (SQLException ignored) {
            } finally {
                if(stmt != null){
                    try{
                        stmt.close();
                    }catch (SQLException ignored){}
                }
            }
            releaseConnection(connection);
        }

        int cleanPercent = (int) Math.round((((double) cleanCount)/(cleanCount+maliciousCount))*100);
        int malwarePercent = (int) Math.round((((double) maliciousCount)/(cleanCount+maliciousCount))*100);

        maliciousSamplesLabel.setText(String.format("Malicious Samples: %d (%d%%)", maliciousCount, malwarePercent));
        cleanSamplesLabel.setText(String.format("Clean Samples: %d (%d%%)", cleanCount, cleanPercent));
        int activeConnections = 0;
        for (Object o : this.connections.values()) {
            if(o != null) activeConnections++;
        }
        activeConnectionsLabel.setText("Active Connections: " + activeConnections);
        availableConnectionsLabel.setText("Available Connections: " + (this.connections.size() - activeConnections));
        statPanel.revalidate();
        statPanel.repaint();
        return statPanel;
    }
}
