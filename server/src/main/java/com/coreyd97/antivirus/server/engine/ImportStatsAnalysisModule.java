package com.coreyd97.antivirus.server.engine;

import com.coreyd97.antivirus.common.report.FileFeatures;
import com.coreyd97.antivirus.common.report.MalwareEntry;
import com.coreyd97.antivirus.common.report.ScanReport;
import com.coreyd97.antivirus.common.taskscheduler.AnalysisTask;
import com.coreyd97.antivirus.common.taskscheduler.TrainTask;
import com.coreyd97.antivirus.common.utils.ImportStatsUtils;
import com.coreyd97.antivirus.common.utils.Utils;
import com.coreyd97.antivirus.server.AntiVirusServer;
import com.coreyd97.antivirus.server.DatabaseEngine;
import com.coreyd97.antivirus.server.ui.StatProvider;
import com.coreyd97.c45.C45;
import com.coreyd97.c45.DataElement;
import com.coreyd97.c45.Feature;
import com.coreyd97.c45.TreeNode;
import com.github.katjahahn.parser.FileFormatException;
import com.github.katjahahn.parser.PEData;
import com.github.katjahahn.parser.PELoader;
import com.github.katjahahn.parser.sections.SectionLoader;
import com.github.katjahahn.parser.sections.idata.*;
import com.google.gson.Gson;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.io.*;
import java.sql.*;
import java.util.*;
import java.util.logging.Logger;

public class ImportStatsAnalysisModule extends AnalysisModule implements StatProvider {
    public static final String engineName = "Function Import Heuristic";
    private int moduleID;
    private DatabaseEngine db;
    private boolean isSetup = false;

    //Classification
    private TreeNode decisionTree;

    public ImportStatsAnalysisModule() throws SQLException {
        super(engineName, true);
    }

    public void setup(DatabaseEngine db){
        this.db = db;

        String createDLLTable ="CREATE TABLE IF NOT EXISTS DLL(ID INT AUTO_INCREMENT PRIMARY KEY, DLLName VARCHAR(256))";
        String createFunctionsTable = "CREATE TABLE IF NOT EXISTS Functions(ID INT AUTO_INCREMENT PRIMARY KEY, DLLID INT, FunctionName VARCHAR(512)," +
                " FOREIGN KEY (DLLID) REFERENCES DLL(ID) ON DELETE CASCADE ON UPDATE CASCADE)";
        String createUsageTable = "CREATE TABLE IF NOT EXISTS FunctionUsage(SampleID INT, FunctionID INT, PRIMARY KEY(SampleID, FunctionID)," +
                " FOREIGN KEY (SampleID) REFERENCES Samples(ID) ON DELETE CASCADE ON UPDATE CASCADE," +
                " FOREIGN KEY (FunctionID) REFERENCES Functions(ID) ON DELETE CASCADE ON UPDATE CASCADE)";

        Connection conn = db.getConnection(this);
        try {
            Statement statement = conn.createStatement();
            statement.executeUpdate(createDLLTable);
            statement.executeUpdate(createFunctionsTable);
            statement.executeUpdate(createUsageTable);
            this.moduleID = db.registerModule(conn, ImportStatsAnalysisModule.engineName);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        db.releaseConnection(conn);

        File treeFile = new File("./config/importRuleTree");
        try {
            decisionTree = new Gson().fromJson(new FileReader(treeFile), TreeNode.class);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            //TODO handle missing decision tree.
            //TODO Add ability for server to report errors to client w/r processing reports.
        }
        isSetup = true;
    }

    @Override
    public TrainTask train(Utils.FileStatus fileStatus, File files[]){
        ImportStatsTrainTask trainTask = new ImportStatsTrainTask("Import Stats Training", files, fileStatus);
        return trainTask;
    }

    @Override
    public AnalysisTask processReport(ScanReport scanReport) {
        AnalysisTask analysisTask = new ImportStatsAnalysisTask("Import Stats Report Analysis", scanReport);
        return analysisTask;
    }



    private class ImportStatsAnalysisTask extends AnalysisTask {

        protected ImportStatsAnalysisTask(String taskName, ScanReport report) {
            super(taskName, report);
        }

        @Override
        protected void processFile(FileFeatures fileFeatures) {
            //Features are sent as list of DllFunction.
            Connection connection = db.getConnection(this);
            HashSet<String> functionIDs = new HashSet<>();
            for (String dllName : fileFeatures.mapOfLists.keySet()) {
                try {
                    int dllID = getDLLID(connection, dllName);
                    for (String functionName : fileFeatures.mapOfLists.get(dllName)) {
                        try {
                            int functionID = getFunctionID(connection, dllID, functionName);
                            functionIDs.add(String.valueOf(functionID));
                        }catch (SQLException ignored){}
                    }
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            db.releaseConnection(connection);
            System.out.print(functionIDs);

            DataElement element = new DataElement(null, null, functionIDs);
            if(decisionTree.classify(element).equalsIgnoreCase("MALWARE")) {
                System.out.println(" - Malware");
                resultsReport.addMalware(new MalwareEntry(fileFeatures.filePath, -0, ""));
            }else{
                System.out.println(" - Clean");
            }
        }

        @Override
        public void run() {
            if(!ImportStatsAnalysisModule.this.isSetup){
                setup(AntiVirusServer.getInstance().getDatabaseEngine());
            }
            super.run();
        }
    }

    public class ImportStatsTrainTask extends TrainTask {
        Utils.FileStatus fileStatus;

        ImportStatsTrainTask(String taskName, File files[], Utils.FileStatus fileStatus) {
            super(taskName, files, ImportStatsAnalysisModule.this);
            this.fileStatus = fileStatus;
        }

        @Override
        protected void processFile(File file) {
            Connection connection = db.getConnection(this);
            try {
                connection.setAutoCommit(false);
                PEData data = PELoader.loadPE(file);
                SectionLoader sectionLoader = new SectionLoader(data);
                ImportSection imports = sectionLoader.loadImportSection();

                int sampleID = db.addSampleIfNotExists(connection, file, fileStatus == Utils.FileStatus.MALWARE);
                if (db.isModuleTrained(connection, moduleID, sampleID)) {
                    //We've already trained the module on this sample.
                    this.report.incrementExisting();
                    db.releaseConnection(connection);
                    return;
                }

                storeImports(connection, sampleID, ImportStatsUtils.convertToImportMap(imports.getImports()));
                this.report.incrementTrained();
                db.markSampleTrained(connection, moduleID, sampleID);
                connection.commit();
            } catch (IOException | IllegalStateException e) {
                String cause;
                if (e instanceof FileFormatException) {
                    cause = "Invalid PE32 File. ";
                } else if (e instanceof IllegalStateException) {
                    cause = "Could not find import section. ";
                } else {
                    cause = "Could not open file. ";
                }
                this.report.addFailedSample(cause);
            } catch (SQLException e) {
                e.printStackTrace();
                this.report.incrementFailed();
            }finally {
                try{
                    connection.setAutoCommit(true);
                }catch (SQLException ignored){}
            }
            db.releaseConnection(connection);
        }

        @Override
        public void run() {
            if (!ImportStatsAnalysisModule.this.isSetup) {
                setup(AntiVirusServer.getInstance().getDatabaseEngine());
            }
            super.run();
            try {
                createTree();
            } catch (SQLException e) {}
            this.report.display();
        }
    }

    private int getDLLID(Connection connection, String dllName) throws SQLException{
        PreparedStatement stmt = connection.prepareStatement("SELECT ID from DLL WHERE DLLNAME=? LIMIT 1");
        try {
            stmt.setString(1, dllName);
            ResultSet results = stmt.executeQuery();
            if (results.next()) {
                return results.getInt(1);
            } else {
                stmt = connection.prepareStatement("INSERT INTO DLL VALUES (NULL, ?)", PreparedStatement.RETURN_GENERATED_KEYS);
                stmt.setString(1, dllName);
                stmt.executeUpdate();
                results = stmt.getGeneratedKeys();
                if (results.next()) {
                    return results.getInt(1);
                }
            }
        }finally{
            stmt.close();
        }
        return -1;
    }

    private int getFunctionID(Connection connection, int dllID, String function) throws SQLException {
        PreparedStatement stmt = connection.prepareStatement("SELECT ID from FUNCTIONS WHERE DLLID=? AND FUNCTIONNAME=? LIMIT 1");
        try {
            stmt.setInt(1, dllID);
            stmt.setString(2, function);
            ResultSet results = stmt.executeQuery();
            if (results.next()) {
                return results.getInt(1);
            } else {
                stmt = connection.prepareStatement("INSERT INTO FUNCTIONS VALUES (NULL, ?, ?)", PreparedStatement.RETURN_GENERATED_KEYS);
                stmt.setInt(1, dllID);
                stmt.setString(2, function);
                stmt.executeUpdate();
                results = stmt.getGeneratedKeys();
                if (results.next()) {
                    return results.getInt(1);
                }
            }
        }finally {
            stmt.close();
        }
        return -1;
    }

    private boolean storeImportUsage(Connection connection, int sampleID, int functionID) throws SQLException {
        PreparedStatement stmt = connection.prepareStatement("INSERT INTO FUNCTIONUSAGE VALUES (?, ?)");
        try {
            stmt.setInt(1, sampleID);
            stmt.setInt(2, functionID);
            try {
                int effectedRows = stmt.executeUpdate();
                return effectedRows != 0;
            } catch (SQLException ignored) {
            }
            return false;
        }finally {
            stmt.close();
        }
    }

    private void storeImports(Connection connection, int sampleID, HashMap<String, ArrayList<String>> imports) throws SQLException {
        for (String dllName : imports.keySet()) {
            try {
                int dllID = getDLLID(connection, dllName);
                ArrayList<String> functions = imports.get(dllName);
                for (String functionName : functions) {
                    try {
                        int functionID = getFunctionID(connection, dllID, functionName);
                        storeImportUsage(connection, sampleID, functionID);
                    } catch (SQLException sqlException) {
                        sqlException.printStackTrace();
                    }
                }
            }catch (SQLException ignored){}
        }
    }

    public void createTree() throws SQLException {
        int minInstances = 10;
        C45 c45 = new C45("CLEAN", "MALWARE", minInstances);
        HashMap<Integer, DataElement> dataElements = new HashMap<>();
        HashMap<Integer, Feature> features = new HashMap<>();

        String selectFunctions = "SELECT FUNCTIONS.ID FROM DLL LEFT JOIN FUNCTIONS ON DLL.ID = FUNCTIONS.DLLID";
        String selectFunctionsMinUsage = "SELECT FUNCTIONID FROM (SELECT FUNCTIONID, COUNT(FUNCTIONID) as count FROM FUNCTIONUSAGE GROUP BY FUNCTIONID) WHERE count>?";
        String selectSamples = "SELECT SAMPLEID, MALWARE FROM TRAINING LEFT JOIN (SELECT ID, MALWARE FROM SAMPLES) AS S ON S.ID=TRAINING.SAMPLEID WHERE TRAINING.MODULEID=?";
        String selectFunctionMatches = "SELECT SAMPLEID, FUNCTIONID FROM FUNCTIONUSAGE";

        Connection connection = db.getConnection(this);

        //TODO explain move to minimum occurcences function select
        PreparedStatement stmt = connection.prepareStatement(selectFunctionsMinUsage);
        stmt.setInt(1, minInstances);
        ResultSet rs = stmt.executeQuery();
        while (rs.next()) {
            int functionID = rs.getInt(1);
            Feature f = new Feature(String.valueOf(functionID));
            features.put(functionID, f);
        }
        stmt.close();

        stmt = connection.prepareStatement(selectSamples);
        stmt.setInt(1, this.moduleID);
        rs = stmt.executeQuery();
        while (rs.next()) {
            int id = rs.getInt(1);
            String classification = rs.getBoolean(2) ? "MALWARE" : "CLEAN";
            DataElement elem = new DataElement(classification, null, new HashSet<>());
            dataElements.put(id, elem);
        }
        stmt.close();

        stmt = connection.prepareStatement(selectFunctionMatches);
        rs = stmt.executeQuery();
        while (rs.next()) {
            int sampleID = rs.getInt(1);
            int functionID = rs.getInt(2);
            dataElements.get(sampleID).labels.add(String.valueOf(functionID));
        }
        stmt.close();

        db.releaseConnection(connection);

        c45.addFeatures(new ArrayList<>(features.values()));
        c45.addTrainingElements(new ArrayList<>(dataElements.values()));
        long t = System.currentTimeMillis();
        Logger.getLogger("CREATETREE").info("Start - " + t);
        c45.createTree();
        Logger.getLogger("CREATETREE").info("End - " + ((System.currentTimeMillis() - t)/60000));


        Gson gson = new Gson();
        String tree = gson.toJson(c45.root);
        File ruleTree = new File("./config/importRuleTree");
        PrintWriter writer = null;
        try {
            writer = new PrintWriter(new FileWriter(ruleTree));
            writer.println(tree);
            writer.flush();
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static int getDLLCount(Connection connection){
        String dllCount = "SELECT COUNT(*) FROM DLL";
        PreparedStatement stmt = null;
        try {
            stmt = connection.prepareStatement(dllCount);
            ResultSet rs = stmt.executeQuery();
            if(rs.next()) return rs.getInt(1);
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            if(stmt != null){
                try {
                    stmt.close();
                } catch (SQLException ignored) {}
            }
        }
        return 0;
    }

    public static int getFunctionCount(Connection connection){
        String dllCount = "SELECT COUNT(*) FROM FUNCTIONS";
        PreparedStatement stmt = null;
        try {
            stmt = connection.prepareStatement(dllCount);
            ResultSet rs = stmt.executeQuery();
            if(rs.next()) return rs.getInt(1);
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            if(stmt != null){
                try {
                    stmt.close();
                } catch (SQLException ignored) {}
            }
        }
        return 0;
    }

    public static int getUsageCount(Connection connection){
        String dllCount = "SELECT COUNT(*) FROM FUNCTIONUSAGE";
        PreparedStatement stmt = null;
        try {
            stmt = connection.prepareStatement(dllCount);
            ResultSet rs = stmt.executeQuery();
            if(rs.next()) return rs.getInt(1);
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            if(stmt != null){
                try {
                    stmt.close();
                } catch (SQLException ignored) {}
            }
        }
        return 0;
    }

    public static String getFunctionName(Connection conn, Integer funcId) {
        String selectFunctionName = "SELECT CONCAT(DLLNAME, ': ', FUNCTIONNAME) FROM (SELECT * FROM FUNCTIONS WHERE ID=? LIMIT 1) LEFT JOIN DLL ON FUNCTIONS.DLLID=DLL.ID";
        PreparedStatement stmt = null;
        try {
            stmt = conn.prepareStatement(selectFunctionName);
            stmt.setInt(1, funcId);
            ResultSet rs = stmt.executeQuery();
            if(rs.next()) return rs.getString(1);
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            if(stmt != null){
                try {
                    stmt.close();
                } catch (SQLException ignored) {}
            }
        }
        return "";
    }

    @Override
    public JPanel getStatPanel() {
        if(!isSetup) {
            setup(AntiVirusServer.getInstance().getDatabaseEngine());
        }

        Connection connection = db.getConnection(this);
        HashMap<Boolean, Integer> trainedCount = (HashMap<Boolean, Integer>) db.getModuleTrainedCount(connection, this.moduleID);

        JPanel panel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.weightx = gbc.weighty = 1.0;
        gbc.gridx = gbc.gridy = 1;
        gbc.fill = GridBagConstraints.BOTH;
        TitledBorder border = BorderFactory.createTitledBorder("Function Import Analytics");
//        border.setTitleJustification(TitledBorder.CENTER);
        border.setTitleColor(Color.BLUE);
        panel.setBorder(border);
        int cleanSamples = trainedCount.get(false);
        int malwareSamples = trainedCount.get(true);
        int cleanPercent = (int) Math.round((((double) cleanSamples)/(cleanSamples+malwareSamples))*100);
        int malwarePercent = (int) Math.round((((double) malwareSamples)/(cleanSamples+malwareSamples))*100);
        panel.add(new JLabel(String.format("Clean Samples: %d (%d%%)", cleanSamples, cleanPercent)), gbc);
        gbc.gridy++;
        panel.add(new JLabel(String.format("Malicious Samples: %d (%d%%)", malwareSamples, malwarePercent)), gbc);
        gbc.gridy = 1;
        gbc.gridx++;
        panel.add(new JLabel(String.format("DLL Count: %d", getDLLCount(connection))), gbc);
        gbc.gridy++;
        panel.add(new JLabel(String.format("Function Count: %d", getFunctionCount(connection))), gbc);
        gbc.gridy++;
        panel.add(new JLabel(String.format("Recorded Usages: %d", getUsageCount(connection))), gbc);
        db.releaseConnection(connection);

        gbc.gridx = 1;
        gbc.gridwidth = 2;
        gbc.gridy = 10;
        panel.add(new JLabel("Ready to Classify: " + (this.decisionTree == null ? "FALSE" : "TRUE")), gbc);

        return panel;
    }



}
