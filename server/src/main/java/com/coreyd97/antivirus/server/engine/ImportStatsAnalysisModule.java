package com.coreyd97.antivirus.server.engine;

import com.coreyd97.antivirus.common.report.FileFeatures;
import com.coreyd97.antivirus.common.report.MalwareEntry;
import com.coreyd97.antivirus.common.report.ScanReport;
import com.coreyd97.antivirus.common.report.TrainReport;
import com.coreyd97.antivirus.common.taskscheduler.AnalysisTask;
import com.coreyd97.antivirus.common.taskscheduler.TrainTask;
import com.coreyd97.antivirus.common.utils.ImportStatsUtils;
import com.coreyd97.antivirus.common.utils.ImportStatsUtils.DllFunction;
import com.coreyd97.antivirus.common.utils.Utils;
import com.coreyd97.antivirus.server.AntiVirusServer;
import com.coreyd97.antivirus.server.DatabaseEngine;
import com.coreyd97.antivirus.server.ui.StatProvider;
import com.coreyd97.c45.C45;
import com.coreyd97.c45.DataElement;
import com.coreyd97.c45.Feature;
import com.coreyd97.c45.TreeNode;
import com.github.katjahahn.parser.FileFormatException;
import com.github.katjahahn.parser.PEData;
import com.github.katjahahn.parser.PELoader;
import com.github.katjahahn.parser.sections.SectionLoader;
import com.github.katjahahn.parser.sections.idata.*;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.internal.LinkedTreeMap;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.io.*;
import java.sql.*;
import java.util.*;
import java.util.List;

public class ImportStatsAnalysisModule extends AnalysisModule implements StatProvider {
    public static final String engineName = "Function Import Heuristic";
    private int moduleID;
    private DatabaseEngine db;
    private boolean isSetup = false;

    //Classification
    private TreeNode decisionTree;

    public ImportStatsAnalysisModule() throws SQLException {
        super(engineName, true);
    }

    void setup(DatabaseEngine db){
        this.db = db;

        String createDLLTable ="CREATE TABLE IF NOT EXISTS DLL(ID INT AUTO_INCREMENT PRIMARY KEY, DLLName VARCHAR(256))";
        String createFunctionsTable = "CREATE TABLE IF NOT EXISTS Functions(ID INT AUTO_INCREMENT PRIMARY KEY, DLLID INT, FunctionName VARCHAR(512), FOREIGN KEY (DLLID) REFERENCES DLL(ID))";
        String createUsageTable = "CREATE TABLE IF NOT EXISTS FunctionUsage(SampleID INT, FunctionID INT, PRIMARY KEY(SampleID, FunctionID), FOREIGN KEY (SampleID) REFERENCES Samples(ID), FOREIGN KEY (FunctionID) REFERENCES Functions(ID))";

        Connection conn = db.getConnection();
        try {
            Statement statement = conn.createStatement();
            statement.executeUpdate(createDLLTable);
            statement.executeUpdate(createFunctionsTable);
            statement.executeUpdate(createUsageTable);
            this.moduleID = db.registerModule(ImportStatsAnalysisModule.engineName);
        } catch (SQLException e) {
            e.printStackTrace();
        }

        File treeFile = new File("./config/importRuleTree");
        try {
            decisionTree = new Gson().fromJson(new FileReader(treeFile), TreeNode.class);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            //TODO handle missing decision tree.
            //TODO Add ability for server to report errors to client w/r processing reports.
        }
        isSetup = true;
    }

    @Override
    public TrainTask train(Utils.FileStatus fileStatus, File files[]){
        ImportStatsTrainTask trainTask = new ImportStatsTrainTask("Import Stats Training", files, fileStatus);
        return trainTask;
    }

    @Override
    public AnalysisTask processReport(ScanReport scanReport) {
        AnalysisTask analysisTask = new ImportStatsAnalysisTask("Import Stats Report Analysis", scanReport);
        return analysisTask;
    }

    public class ImportStatsTrainTask extends TrainTask {
        Utils.FileStatus fileStatus;

        ImportStatsTrainTask(String taskName, File files[], Utils.FileStatus fileStatus) {
            super(taskName, files, ImportStatsAnalysisModule.this);
            this.fileStatus = fileStatus;
        }

        @Override
        protected void processFile(File file) {
            try {
                int sampleID = db.addSample(file, fileStatus == Utils.FileStatus.MALWARE);
                if (db.isModuleTrained(moduleID, sampleID)) {
                    //We've already trained the module on this sample.
                    this.report.existingSamples++;
                    return;
                }
                PEData data = PELoader.loadPE(file);
                SectionLoader sectionLoader = new SectionLoader(data);
                ImportSection imports = sectionLoader.loadImportSection();
                storeImports(sampleID, ImportStatsUtils.convertToImportMap(imports.getImports()));
                this.report.trainedSamples++;
                db.markSampleTrained(moduleID, sampleID);
            } catch (IOException | IllegalStateException e) {
                String cause;
                if (e instanceof FileFormatException) {
                    cause = "Invalid PE32 File. ";
                } else if (e instanceof IllegalStateException) {
                    cause = "Could not find import section. ";
                } else {
                    cause = "Could not open file. ";
                }
                this.report.addFailedSample(cause);
                this.report.failedSamples++;
            } catch (SQLException e) {
                e.printStackTrace();
                this.report.failedSamples++;
            }
        }

        @Override
        public void run() {
            if (!ImportStatsAnalysisModule.this.isSetup) {
                setup(AntiVirusServer.getInstance().getDatabaseEngine());
            }
            super.run();
            try {
                createTree();
            } catch (SQLException e) {}
            this.report.display();
        }
    }

    private class ImportStatsAnalysisTask extends AnalysisTask {

        protected ImportStatsAnalysisTask(String taskName, ScanReport report) {
            super(taskName, report);
        }

        @Override
        protected void processFile(FileFeatures fileFeatures) {
            //Features are sent as list of DllFunction.
            HashSet<String> functionIDs = new HashSet<>();
            for (String dllName : fileFeatures.mapOfLists.keySet()) {
                try {
                    int dllID = getDLLID(dllName);
                    for (String functionName : fileFeatures.mapOfLists.get(dllName)) {
                        int functionID = getFunctionID(dllID, functionName);
                        functionIDs.add(String.valueOf(functionID));
                    }
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            DataElement element = new DataElement(null, null, functionIDs);
            if(decisionTree.classify(element).equalsIgnoreCase("MALWARE")) {
                resultsReport.addMalware(new MalwareEntry(fileFeatures.filePath, -0, ""));
            }
        }

        @Override
        public void run() {
            if(!ImportStatsAnalysisModule.this.isSetup){
                setup(AntiVirusServer.getInstance().getDatabaseEngine());
            }
            super.run();
        }
    }

    private int getDLLID(String dllName) throws SQLException{
        PreparedStatement stmt = db.getConnection().prepareStatement("SELECT ID from DLL WHERE DLLNAME=? LIMIT 1");
        stmt.setString(1, dllName);
        ResultSet results = stmt.executeQuery();
        if(results.next()){
            return results.getInt(1);
        }else{
            stmt = db.getConnection().prepareStatement("INSERT INTO DLL VALUES (NULL, ?)", PreparedStatement.RETURN_GENERATED_KEYS);
            stmt.setString(1, dllName);
            stmt.executeUpdate();
            results = stmt.getGeneratedKeys();
            if(results.next()){
                return results.getInt(1);
            }
        }
        return -1;
    }

    private int getFunctionID(int dllID, String function) throws SQLException {
        PreparedStatement stmt = db.getConnection().prepareStatement("SELECT ID from FUNCTIONS WHERE DLLID=? AND FUNCTIONNAME=? LIMIT 1");
        stmt.setInt(1, dllID);
        stmt.setString(2, function);
        ResultSet results = stmt.executeQuery();
        if(results.next()){
            return results.getInt(1);
        }else{
            stmt = db.getConnection().prepareStatement("INSERT INTO FUNCTIONS VALUES (NULL, ?, ?)", PreparedStatement.RETURN_GENERATED_KEYS);
            stmt.setInt(1, dllID);
            stmt.setString(2, function);
            stmt.executeUpdate();
            results = stmt.getGeneratedKeys();
            if(results.next()){
                return results.getInt(1);
            }
        }
        return -1;
    }

    private boolean storeImportUsage(int sampleID, int functionID) throws SQLException {
        PreparedStatement stmt = db.getConnection().prepareStatement("INSERT INTO FUNCTIONUSAGE VALUES (?, ?)");
        stmt.setInt(1, sampleID);
        stmt.setInt(2, functionID);
        try {
            int effectedRows = stmt.executeUpdate();
            return effectedRows != 0;
        }catch (SQLException ignored){}
        return false;
    }

    private void storeImports(int sampleID, HashMap<String, ArrayList<String>> imports) throws SQLException {
        for (String dllName : imports.keySet()) {
            int dllID = getDLLID(dllName);
            ArrayList<String> functions = imports.get(dllName);
            for (String functionName : functions) {
                int functionID = getFunctionID(dllID, functionName);
                storeImportUsage(sampleID, functionID);
            }
        }
    }

    private void createTree() throws SQLException {
        C45 c45 = new C45("CLEAN", "MALWARE", 5);
        HashMap<Integer, DataElement> dataElements = new HashMap<>();
        HashMap<Integer, Feature> features = new HashMap<>();

        String selectFunctions = "SELECT FUNCTIONS.ID, CONCAT(DLLNAME, ':', FUNCTIONNAME) FROM DLL LEFT JOIN FUNCTIONS ON DLL.ID = FUNCTIONS.DLLID";
        String selectSamples = "SELECT ID, MALWARE FROM SAMPLES";
        String selectFunctionMatches = "SELECT SAMPLEID, FUNCTIONID FROM FUNCTIONUSAGE";

        Statement stmt = db.getConnection().createStatement();
        ResultSet rs = stmt.executeQuery(selectFunctions);
        while (rs.next()) {
            int functionID = rs.getInt(1);
            String functionName = rs.getString(2);
            Feature f = new Feature(String.valueOf(functionID));
            features.put(functionID, f);
        }

        rs = stmt.executeQuery(selectSamples);
        while (rs.next()) {
            int id = rs.getInt(1);
            String classification = rs.getBoolean(2) ? "MALWARE" : "CLEAN";
            DataElement elem = new DataElement(classification, null, new HashSet<>());
            dataElements.put(id, elem);
        }

        rs = stmt.executeQuery(selectFunctionMatches);
        while (rs.next()) {
            int sampleID = rs.getInt(1);
            int functionID = rs.getInt(2);
            dataElements.get(sampleID).labels.add(String.valueOf(functionID));
        }

        c45.addFeatures(new ArrayList<>(features.values()));
        c45.addTrainingElements(new ArrayList<>(dataElements.values()));
        c45.createTree();

        Gson gson = new Gson();
        String tree = gson.toJson(c45.root);
        File ruleTree = new File("./config/importRuleTree");
        PrintWriter writer = null;
        try {
            writer = new PrintWriter(new FileWriter(ruleTree));
            writer.println(tree);
            writer.flush();
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public int getDLLCount(){
        String dllCount = "SELECT COUNT(*) FROM DLL";
        try {
            PreparedStatement stmt = db.getConnection().prepareStatement(dllCount);
            ResultSet rs = stmt.executeQuery();
            if(rs.next()) return rs.getInt(1);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return 0;
    }

    public int getFunctionCount(){
        String dllCount = "SELECT COUNT(*) FROM FUNCTIONS";
        try {
            PreparedStatement stmt = db.getConnection().prepareStatement(dllCount);
            ResultSet rs = stmt.executeQuery();
            if(rs.next()) return rs.getInt(1);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return 0;
    }

    public int getUsageCount(){
        String dllCount = "SELECT COUNT(*) FROM FUNCTIONUSAGE";
        try {
            PreparedStatement stmt = db.getConnection().prepareStatement(dllCount);
            ResultSet rs = stmt.executeQuery();
            if(rs.next()) return rs.getInt(1);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return 0;
    }

    @Override
    public JPanel getStatPanel() {
        if(!isSetup) {
            setup(AntiVirusServer.getInstance().getDatabaseEngine());
        }
        HashMap<Boolean, Integer> trainedCount = (HashMap<Boolean, Integer>) db.getModuleTrainedCount(this.moduleID);

        JPanel panel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.weightx = gbc.weighty = 1.0;
        gbc.gridx = gbc.gridy = 1;
        gbc.fill = GridBagConstraints.BOTH;
        TitledBorder border = BorderFactory.createTitledBorder("Function Import Analytics");
//        border.setTitleJustification(TitledBorder.CENTER);
        border.setTitleColor(Color.BLUE);
        panel.setBorder(border);
        panel.add(new JLabel(String.format("Clean Samples Trained: %d", trainedCount.get(false))), gbc);
        gbc.gridy++;
        panel.add(new JLabel(String.format("Malicious Samples Trained: %d", trainedCount.get(true))), gbc);
        gbc.gridy = 1;
        gbc.gridx++;
        panel.add(new JLabel(String.format("DLL Count: %d", getDLLCount())), gbc);
        gbc.gridy++;
        panel.add(new JLabel(String.format("Function Count: %d", getFunctionCount())), gbc);
        gbc.gridy++;
        panel.add(new JLabel(String.format("Recorded Usages: %d", getUsageCount())), gbc);

        gbc.gridx = 1;
        gbc.gridwidth = 2;
        gbc.gridy = 10;
        panel.add(new JLabel("Ready to Classify: " + (this.decisionTree == null ? "FALSE" : "TRUE")), gbc);

        return panel;
    }



}
