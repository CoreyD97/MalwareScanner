package com.coreyd97.antivirus.server.engine;

import com.coreyd97.antivirus.common.report.Explanation;
import com.coreyd97.antivirus.common.report.FileFeatures;
import com.coreyd97.antivirus.common.report.MalwareEntry;
import com.coreyd97.antivirus.common.report.ScanReport;
import com.coreyd97.antivirus.common.taskscheduler.AnalysisTask;
import com.coreyd97.antivirus.common.taskscheduler.TrainTask;
import com.coreyd97.antivirus.common.utils.ImportStatsUtils;
import com.coreyd97.antivirus.common.utils.Utils;
import com.coreyd97.antivirus.server.DatabaseEngine;
import com.coreyd97.antivirus.server.taskscheduler.ExplainTask;
import com.coreyd97.antivirus.common.stats.StatProvider;
import com.coreyd97.c45.C45;
import com.coreyd97.c45.DataElement;
import com.coreyd97.c45.Feature;
import com.coreyd97.c45.TreeNode;
import com.github.katjahahn.parser.FileFormatException;
import com.github.katjahahn.parser.PEData;
import com.github.katjahahn.parser.PELoader;
import com.github.katjahahn.parser.sections.SectionLoader;
import com.github.katjahahn.parser.sections.idata.*;
import com.google.gson.Gson;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import javax.xml.crypto.Data;
import java.awt.*;
import java.io.*;
import java.sql.*;
import java.util.*;
import java.util.logging.Logger;

public class ImportStatsAnalysisModule extends AnalysisModule implements StatProvider {
    public static final String engineName = "Function Import Heuristic";
    private int moduleID;
    private DatabaseEngine databaseEngine;
    private boolean isSetup = false;

    //Classification
    private TreeNode decisionTree;

    public ImportStatsAnalysisModule(AnalysisManager analysisManager) throws SQLException {
        super(engineName, true);
        this.databaseEngine = analysisManager.getDatabaseEngine();

        createTables();
        loadTree();
    }

    private void createTables(){
        String createDLLTable ="CREATE TABLE IF NOT EXISTS DLL(ID INT AUTO_INCREMENT PRIMARY KEY, DLLName VARCHAR(256))";
        String createFunctionsTable = "CREATE TABLE IF NOT EXISTS Functions(ID INT AUTO_INCREMENT PRIMARY KEY, DLLID INT, FunctionName VARCHAR(512)," +
                " FOREIGN KEY (DLLID) REFERENCES DLL(ID) ON DELETE CASCADE ON UPDATE CASCADE)";
        String createUsageTable = "CREATE TABLE IF NOT EXISTS FunctionUsage(SampleID INT, FunctionID INT, PRIMARY KEY(SampleID, FunctionID)," +
                " FOREIGN KEY (SampleID) REFERENCES Samples(ID) ON DELETE CASCADE ON UPDATE CASCADE," +
                " FOREIGN KEY (FunctionID) REFERENCES Functions(ID) ON DELETE CASCADE ON UPDATE CASCADE)";

        Connection conn = databaseEngine.getConnection(this);
        try {
            Statement statement = conn.createStatement();
            statement.executeUpdate(createDLLTable);
            statement.executeUpdate(createFunctionsTable);
            statement.executeUpdate(createUsageTable);
            this.moduleID = DatabaseEngine.registerModule(conn, ImportStatsAnalysisModule.engineName);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        databaseEngine.releaseConnection(conn);
    }

    private void loadTree(){
        File treeFile = new File("./config/importRuleTree");
        try {
            decisionTree = new Gson().fromJson(new FileReader(treeFile), TreeNode.class);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            //TODO handle missing decision tree.
            //TODO Add ability for server to report errors to client w/r processing reports.
        }
    }


    @Override
    public TrainTask train(Utils.FileStatus fileStatus, File files[]){
        ImportStatsTrainTask trainTask = new ImportStatsTrainTask("Import Stats Training", files, fileStatus);
        return trainTask;
    }

    @Override
    public AnalysisTask processReport(ScanReport scanReport) {
        AnalysisTask analysisTask = new ImportStatsAnalysisTask("Import Stats Report Analysis", scanReport);
        return analysisTask;
    }

    @Override
    public ExplainTask explain(ScanReport scanReport) {
        return new ImportStatsExplainTask("Import Stats Explanation", scanReport);
    }

    private class ImportStatsAnalysisTask extends AnalysisTask {

        protected ImportStatsAnalysisTask(String taskName, ScanReport report) {
            super(taskName, report);
        }

        @Override
        protected void processFile(FileFeatures fileFeatures) {
            //Features are sent as list of DllFunction.
            Connection connection = databaseEngine.getConnection(this);
            HashSet<String> functionIDs = new HashSet<>();
            for (String dllName : fileFeatures.mapOfLists.keySet()) {
                try {
                    int dllID = getDLLID(connection, dllName);
                    for (String functionName : fileFeatures.mapOfLists.get(dllName)) {
                        try {
                            int functionID = getFunctionID(connection, dllID, functionName);
                            if(functionID != -1) {
                                functionIDs.add(String.valueOf(functionID));
                            }
                        }catch (SQLException ignored){}
                    }
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            databaseEngine.releaseConnection(connection);

            DataElement element = new DataElement(null, null, functionIDs);
            if(decisionTree.classify(element).equalsIgnoreCase("MALWARE")) {
                resultsReport.addMalware(new MalwareEntry(fileFeatures.filePath, -0, "The imported functions were similar to those used by malware."));
            }else{
            }
        }
    }

    private class ImportStatsExplainTask extends ExplainTask {

        protected ImportStatsExplainTask(String taskName, ScanReport report) {
            super(taskName, ImportStatsAnalysisModule.this.decisionTree, report);
        }

        @Override
        protected void processFile(FileFeatures fileFeatures) throws SQLException {
            Connection connection = databaseEngine.getConnection(this);
            HashSet<String> functionIDs = new HashSet<>();

            for (String dllName : fileFeatures.mapOfLists.keySet()) {
                try {
                    int dllID = getDLLID(connection, dllName);
                    for (String functionName : fileFeatures.mapOfLists.get(dllName)) {
                        try {
                            int functionID = getFunctionID(connection, dllID, functionName);
                            if(functionID != -1) {
                                functionIDs.add(String.valueOf(functionID));
                            }
                        }catch (SQLException ignored){}
                    }
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            databaseEngine.releaseConnection(connection);

            DataElement element = new DataElement(null, null, functionIDs);
            String explanation = this.explain(element);
            resultsReport.addExplanation(new Explanation(fileFeatures.filePath, explanation));
        }

        @Override
        public String getReadableAttribute(String attribute) {
            Connection conn = databaseEngine.getConnection(this);
            String name = getFunctionName(conn, Integer.valueOf(attribute));
            databaseEngine.releaseConnection(conn);
            return name;
        }
    }

    public class ImportStatsTrainTask extends TrainTask {
        Utils.FileStatus fileStatus;

        ImportStatsTrainTask(String taskName, File files[], Utils.FileStatus fileStatus) {
            super(taskName, files);
            this.fileStatus = fileStatus;
        }

        @Override
        protected boolean processFile(File file) {
            Connection connection = databaseEngine.getConnection(this);
            try {
                connection.setAutoCommit(false);
                PEData data = PELoader.loadPE(file);
                SectionLoader sectionLoader = new SectionLoader(data);
                ImportSection imports = sectionLoader.loadImportSection();

                //TODO Discuss checking or training AFTER loading import section advantages
                int sampleID = DatabaseEngine.addSampleIfNotExists(connection, file, fileStatus == Utils.FileStatus.MALWARE);
                if (DatabaseEngine.isModuleTrained(connection, moduleID, sampleID)) {
                    //We've already trained the module on this sample.
                    result.incrementExisting();
                    databaseEngine.releaseConnection(connection);
                    return true;
                }

                storeImports(connection, sampleID, ImportStatsUtils.convertToImportMap(imports.getImports()));
                result.incrementTrained();
                DatabaseEngine.markSampleTrained(connection, moduleID, sampleID);
                connection.commit();
            } catch (IOException | IllegalStateException e) {
                String cause;
                if (e instanceof FileFormatException) {
                    cause = "Invalid PE32 File. ";
                } else if (e instanceof IllegalStateException) {
                    cause = "Could not find import section. ";
                } else {
                    cause = "Could not open file. ";
                }
                result.addFailedSample(cause);
            } catch (SQLException e) {
                e.printStackTrace();
                result.incrementFailed();
            }finally {
                try{
                    connection.setAutoCommit(true);
                }catch (SQLException ignored){}
            }
            databaseEngine.releaseConnection(connection);
            return true;
        }

        @Override
        public void run() {
            super.run();
            try {
                createTree();
            } catch (SQLException e) {}
            result.display();
        }
    }

    static int getDLLID(Connection connection, String dllName) throws SQLException{
        PreparedStatement stmt = connection.prepareStatement("SELECT ID from DLL WHERE DLLNAME=? LIMIT 1");
        try {
            stmt.setString(1, dllName);
            ResultSet results = stmt.executeQuery();
            if (results.next()) {
                return results.getInt(1);
            } else {
                return -1;
            }
        }finally{
            stmt.close();
        }
    }

    private int addDll(Connection connection, String dllName) throws SQLException {
        PreparedStatement stmt = connection.prepareStatement("INSERT INTO DLL VALUES (NULL, ?)", PreparedStatement.RETURN_GENERATED_KEYS);
        stmt.setString(1, dllName);
        stmt.executeUpdate();
        ResultSet results = stmt.getGeneratedKeys();
        if (results.next()) {
            dllCount++;
            return results.getInt(1);
        } else {
            return -1;
        }
    }

    static int getFunctionID(Connection connection, int dllID, String function) throws SQLException {
        PreparedStatement stmt = connection.prepareStatement("SELECT ID from FUNCTIONS WHERE DLLID=? AND FUNCTIONNAME=? LIMIT 1");
        try {
            stmt.setInt(1, dllID);
            stmt.setString(2, function);
            ResultSet results = stmt.executeQuery();
            if (results.next()) {
                return results.getInt(1);
            } else {
                return -1;
            }
        }finally {
            stmt.close();
        }
    }

    private int addFunction(Connection connection, int dllID, String function) throws SQLException {
        PreparedStatement stmt = connection.prepareStatement("INSERT INTO FUNCTIONS VALUES (NULL, ?, ?)", PreparedStatement.RETURN_GENERATED_KEYS);
        stmt.setInt(1, dllID);
        stmt.setString(2, function);
        stmt.executeUpdate();
        ResultSet results = stmt.getGeneratedKeys();
        if (results.next()) {
            functionCount++;
            return results.getInt(1);
        }else{
            return -1;
        }
    }

    static boolean storeImportUsage(Connection connection, int sampleID, int functionID) throws SQLException {
        PreparedStatement stmt = connection.prepareStatement("INSERT INTO FUNCTIONUSAGE VALUES (?, ?)");
        try {
            stmt.setInt(1, sampleID);
            stmt.setInt(2, functionID);
            try {
                int effectedRows = stmt.executeUpdate();
                return effectedRows != 0;
            } catch (SQLException ignored) {
            }
            return false;
        }finally {
            stmt.close();
        }
    }

    void storeImports(Connection connection, int sampleID, HashMap<String, ArrayList<String>> imports) throws SQLException {
        for (String dllName : imports.keySet()) {
            try {
                int dllID = getDLLID(connection, dllName);
                if(dllID == -1) dllID = addDll(connection, dllName);
                if(dllID == -1) continue; //Couldn't add the dll? Skip to next.
                ArrayList<String> functions = imports.get(dllName);
                for (String functionName : functions) {
                    try {
                        int functionID = getFunctionID(connection, dllID, functionName);
                        if(functionID == -1) functionID = addFunction(connection, dllID, functionName);
                        if(functionID == -1) continue; //Couldn't add function? Skip to next.
                        storeImportUsage(connection, sampleID, functionID);
                        recordedUsages++;
                    } catch (SQLException sqlException) {
                        sqlException.printStackTrace();
                    }
                }
            }catch (SQLException ignored){}
        }
    }

    public void createTree() throws SQLException {
        int minInstances = 10;
        C45 c45 = new C45("CLEAN", "MALWARE", minInstances);
        HashMap<Integer, DataElement> dataElements = new HashMap<>();
        HashMap<Integer, Feature> features = new HashMap<>();

        String selectFunctions = "SELECT FUNCTIONS.ID FROM DLL LEFT JOIN FUNCTIONS ON DLL.ID = FUNCTIONS.DLLID";
        String selectFunctionsMinUsage = "SELECT FUNCTIONID FROM (SELECT FUNCTIONID, COUNT(FUNCTIONID) as count FROM FUNCTIONUSAGE GROUP BY FUNCTIONID) WHERE count>?";
        String selectSamples = "SELECT SAMPLEID, MALWARE FROM TRAINING LEFT JOIN (SELECT ID, MALWARE FROM SAMPLES) AS S ON S.ID=TRAINING.SAMPLEID WHERE TRAINING.MODULEID=?";
        String selectFunctionMatches = "SELECT SAMPLEID, FUNCTIONID FROM FUNCTIONUSAGE";

        Connection connection = databaseEngine.getConnection(this);

        //TODO explain move to minimum occurcences function select
        PreparedStatement stmt = connection.prepareStatement(selectFunctionsMinUsage);
        stmt.setInt(1, minInstances);
        ResultSet rs = stmt.executeQuery();
        while (rs.next()) {
            int functionID = rs.getInt(1);
            Feature f = new Feature(String.valueOf(functionID));
            features.put(functionID, f);
        }
        stmt.close();

        stmt = connection.prepareStatement(selectSamples);
        stmt.setInt(1, this.moduleID);
        rs = stmt.executeQuery();
        while (rs.next()) {
            int id = rs.getInt(1);
            String classification = rs.getBoolean(2) ? "MALWARE" : "CLEAN";
            DataElement elem = new DataElement(classification, null, new HashSet<>());
            dataElements.put(id, elem);
        }
        stmt.close();

        stmt = connection.prepareStatement(selectFunctionMatches);
        rs = stmt.executeQuery();
        while (rs.next()) {
            int sampleID = rs.getInt(1);
            int functionID = rs.getInt(2);
            dataElements.get(sampleID).labels.add(String.valueOf(functionID));
        }
        stmt.close();

        databaseEngine.releaseConnection(connection);

        c45.addFeatures(new ArrayList<>(features.values()));
        c45.addTrainingElements(new ArrayList<>(dataElements.values()));
        long t = System.currentTimeMillis();
        Logger.getLogger("CREATETREE").info("Start - " + t);
        c45.createTree();
        Logger.getLogger("CREATETREE").info("End - " + ((System.currentTimeMillis() - t)/60000));


        Gson gson = new Gson();
        String tree = gson.toJson(c45.root);
        File ruleTree = new File("./config/importRuleTree");
        PrintWriter writer = null;
        try {
            writer = new PrintWriter(new FileWriter(ruleTree));
            writer.println(tree);
            writer.flush();
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    static int getDLLCount(Connection connection){
        String dllCount = "SELECT COUNT(*) FROM DLL";
        PreparedStatement stmt = null;
        try {
            stmt = connection.prepareStatement(dllCount);
            ResultSet rs = stmt.executeQuery();
            if(rs.next()) return rs.getInt(1);
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            if(stmt != null){
                try {
                    stmt.close();
                } catch (SQLException ignored) {}
            }
        }
        return 0;
    }

    static int getFunctionCount(Connection connection){
        String dllCount = "SELECT COUNT(*) FROM FUNCTIONS";
        PreparedStatement stmt = null;
        try {
            stmt = connection.prepareStatement(dllCount);
            ResultSet rs = stmt.executeQuery();
            if(rs.next()) return rs.getInt(1);
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            if(stmt != null){
                try {
                    stmt.close();
                } catch (SQLException ignored) {}
            }
        }
        return 0;
    }

    static int getUsageCount(Connection connection){
        String dllCount = "SELECT COUNT(*) FROM FUNCTIONUSAGE";
        PreparedStatement stmt = null;
        try {
            stmt = connection.prepareStatement(dllCount);
            ResultSet rs = stmt.executeQuery();
            if(rs.next()) return rs.getInt(1);
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            if(stmt != null){
                try {
                    stmt.close();
                } catch (SQLException ignored) {}
            }
        }
        return 0;
    }

    public static String getFunctionName(Connection conn, Integer funcId) {
        String selectFunctionName = "SELECT CONCAT(DLLNAME, ': ', FUNCTIONNAME) FROM (SELECT * FROM FUNCTIONS WHERE ID=? LIMIT 1) AS F LEFT JOIN DLL ON F.DLLID=DLL.ID";
        PreparedStatement stmt = null;
        try {
            stmt = conn.prepareStatement(selectFunctionName);
            stmt.setInt(1, funcId);
            ResultSet rs = stmt.executeQuery();
            if(rs.next()) return rs.getString(1);
        } catch (SQLException e) {
            e.printStackTrace();
        }finally {
            if(stmt != null){
                try {
                    stmt.close();
                } catch (SQLException ignored) {}
            }
        }
        return "";
    }


    JPanel panel;
    int trainedCountMalware, trainedCountClean = 0;
    int dllCount, functionCount, recordedUsages;
    JLabel lblTrainedCountMalware, lblTrainedCountClean, lblDllCount, lblFunctionCount, lblRecordedUsages, lblReady;


    @Override
    public JPanel getStatPanel() {
        if(panel == null){
            panel = new JPanel(new GridBagLayout());
            Connection connection = databaseEngine.getConnection(this);
            HashMap<Boolean, Integer> trainedCount = (HashMap<Boolean, Integer>) DatabaseEngine.getModuleTrainedCount(connection, this.moduleID);
            trainedCountClean = trainedCount.get(false);
            trainedCountMalware = trainedCount.get(true);
            dllCount = getDLLCount(connection);
            functionCount = getFunctionCount(connection);
            recordedUsages = getUsageCount(connection);
            databaseEngine.releaseConnection(connection);

            GridBagConstraints gbc = new GridBagConstraints();
            gbc.weightx = gbc.weighty = 1.0;
            gbc.gridx = gbc.gridy = 1;
            gbc.fill = GridBagConstraints.BOTH;
            TitledBorder border = BorderFactory.createTitledBorder("Function Import Analytics");
            border.setTitleColor(Color.BLUE);
            panel.setBorder(border);
            lblTrainedCountMalware = new JLabel();
            lblTrainedCountClean = new JLabel();
            lblDllCount = new JLabel();
            lblFunctionCount = new JLabel();
            lblRecordedUsages = new JLabel();
            lblReady = new JLabel();

            panel.add(lblTrainedCountClean, gbc);
            gbc.gridy++;
            panel.add(lblTrainedCountMalware, gbc);
            gbc.gridy = 1;
            gbc.gridx++;
            panel.add(lblDllCount, gbc);
            gbc.gridy++;
            panel.add(lblFunctionCount, gbc);
            gbc.gridy++;
            panel.add(lblRecordedUsages, gbc);

            gbc.gridx = 1;
            gbc.gridwidth = 2;
            gbc.gridy = 10;
            panel.add(lblReady, gbc);
        }

        int cleanPercent = (int) Math.round((((double) trainedCountClean)/(trainedCountClean+trainedCountMalware))*100);
        int malwarePercent = (int) Math.round((((double) trainedCountMalware)/(trainedCountClean+trainedCountMalware))*100);
        lblTrainedCountClean.setText(String.format("Clean Samples: %d (%d%%)", trainedCountClean, cleanPercent));
        lblTrainedCountMalware.setText(String.format("Malicious Samples: %d (%d%%)", trainedCountMalware, malwarePercent));
        lblDllCount.setText(String.format("DLL Count: %d", dllCount));
        lblFunctionCount.setText(String.format("Function Count: %d", functionCount));
        lblRecordedUsages.setText(String.format("Recorded Usages: %d", recordedUsages));
        lblReady.setText("Ready to Classify: " + (this.decisionTree == null ? "FALSE" : "TRUE"));

        return panel;
    }



}
