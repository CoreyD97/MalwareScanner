package com.coreyd97.antivirus.server.network;

import com.coreyd97.antivirus.common.report.IReportAdapter;
import com.coreyd97.antivirus.common.report.Report;
import com.coreyd97.antivirus.common.report.ResultsReport;
import com.coreyd97.antivirus.common.report.ScanReport;
import com.coreyd97.antivirus.common.taskscheduler.TrainTask;
import com.coreyd97.antivirus.common.utils.ImportStatsUtils;
import com.coreyd97.antivirus.common.utils.Utils;
import com.coreyd97.antivirus.server.AntiVirusServer;
import com.coreyd97.antivirus.server.DatabaseEngine;
import com.coreyd97.antivirus.server.engine.ImportStatsAnalysisModule;
import com.coreyd97.antivirus.server.engine.RulesAnalysisModule;
import com.coreyd97.antivirus.server.engine.UnknownModuleException;
import com.coreyd97.c45.C45;
import com.coreyd97.c45.DataElement;
import com.coreyd97.c45.Feature;
import com.coreyd97.c45.TreeNode;
import com.google.gson.*;

import java.io.*;
import java.net.Socket;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.UUID;
import java.util.logging.Logger;

public class ClientConnection extends Thread {
    final ServerNetworkController serverNetworkController;
    final Socket socket;


    public ClientConnection(ServerNetworkController serverNetworkController, Socket clientSocket){
        this.serverNetworkController = serverNetworkController;
        this.socket = clientSocket;
    }

    @Override
    public void run() {
        BufferedReader bufferedReader;
        PrintWriter outputStream;

        try{
            bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            outputStream = new PrintWriter(socket.getOutputStream(), true);
        } catch (IOException e) {
            for (NetworkListener networkListener : serverNetworkController.getListeners()) {
                networkListener.onNetworkError((ClientNetworkException) e);
            }
            return;
        }

        String line;
        while(!this.socket.isClosed()){
            try{
                line = bufferedReader.readLine();
//                Logger.getLogger("NETWORK").info("Received: " + line);
                switch(line){
                    case "Identify": {
                        outputStream.println("CerberusAVServer");
                        this.socket.close();
                        break;
                    }
                    case "Analyse": {
                        JsonParser jsonParser = new JsonParser();
                        line = bufferedReader.readLine();
                        try{
                            JsonObject jsonObject = (JsonObject) jsonParser.parse(line);
                            if(jsonObject.get("type").getAsString().equals("ScanReport")){
                                ScanReport scanReport = new Gson().fromJson(line,ScanReport.class);

                                //Submit for analysis
                                Logger.getLogger("ANALYSIS").info("Scan Report Received - " + scanReport.getUUID());
                                AntiVirusServer.getInstance().getAnalysisManager().requestAnalysis(scanReport);
                                outputStream.println("ACCEPT " + scanReport.getUUID());
                            }else{
                                outputStream.println("DENY The submitted scanReport was not a ScanReport!");
                            }
                        }catch (JsonParseException parseException){
                            outputStream.println("DENY Could not parse the received ScanReport!");
                        } catch (UnknownModuleException moduleException) {
                            outputStream.println("DENY " + moduleException.getMessage());
                        }
                        this.socket.close();
                        break;
                    }
                    case "Results": {
                        while (!(line = bufferedReader.readLine()).equals("END")) {
                            UUID uuid = UUID.fromString(line);
                            ResultsReport resultsReport = AntiVirusServer.getInstance().getAnalysisManager().getReport(uuid);
                            if (resultsReport == null) {
                                outputStream.println("PENDING");
//                            } else if(resultsReport.getFoundMalware().size() == 0) {
//                                outputStream.println("CLEAN");
                            } else {
                                Gson gson = new GsonBuilder().registerTypeAdapter(Report.class, new IReportAdapter()).create();
                                outputStream.println(gson.toJson(resultsReport, Report.class));
                            }
                        }
                        this.socket.close();
                        break;
                    }
                    case "Train": {
                        line = bufferedReader.readLine();
                        if(!line.equalsIgnoreCase("CLEAN") && !line.equalsIgnoreCase("DIRTY")){
                            outputStream.println(line + " is invalid. Must be either CLEAN or DIRTY");
                            this.socket.close();
                            break;
                        }
                        String filePath = bufferedReader.readLine();
                        File file = new File(filePath);
                        if(!file.exists()){
                            outputStream.println(filePath + " Does not exist.");
                            this.socket.close();
                            break;
                        }
                        Utils.FileStatus status = line.equalsIgnoreCase("clean") ? Utils.FileStatus.CLEAN : Utils.FileStatus.MALWARE;
                        TrainTask task = AntiVirusServer.getInstance().getAnalysisManager().getAnalysisModule(RulesAnalysisModule.engineName).train(status, new File[]{file});
                        task.setCallback(new Runnable() {
                            @Override
                            public void run() {
                                System.out.println("Dirty Training Complete - Success:" + task.getReport().getTrainedSamples() + " - Failed:" + task.getReport().getFailedSamples());
                            }
                        });
//
                        AntiVirusServer.getInstance().getTaskScheduler().submit(task);
                        this.socket.close();
                        break;
                    }

                    case "BUILDIMPORTTREE": {
                        this.socket.close();
                        ImportStatsAnalysisModule module = (ImportStatsAnalysisModule) AntiVirusServer.getInstance().getAnalysisManager().getAnalysisModule(ImportStatsAnalysisModule.engineName);
                        module.setup(AntiVirusServer.getInstance().getDatabaseEngine());
                        try {
                            module.createTree();
                        } catch (SQLException e) {
                            e.printStackTrace();
                        }
                        break;
                    }

                    case "YARATREE": {
                        File treeFile = new File("./config/yaraRuleTree");
                        try {
                            TreeNode decisionTree = new Gson().fromJson(new FileReader(treeFile), TreeNode.class);
                            decisionTree.print();
                        } catch (FileNotFoundException e) {
                            e.printStackTrace();
                            //TODO handle missing decision tree.
                            //TODO Add ability for server to report errors to client w/r processing reports.
                        }
                        this.socket.close();
                        break;
                    }

                    case "IMPORTTREE": {
                        File treeFile = new File("./config/importRuleTree");
                        try {
                            TreeNode decisionTree = new Gson().fromJson(new FileReader(treeFile), TreeNode.class);
                            decisionTree.print();
                        } catch (FileNotFoundException e) {
                            e.printStackTrace();
                            //TODO handle missing decision tree.
                            //TODO Add ability for server to report errors to client w/r processing reports.
                        }
                        this.socket.close();
                        break;
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }



    public static class ClientNetworkException extends IOException{}
}