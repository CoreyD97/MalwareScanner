package com.coreyd97.antivirus.server.network;

import com.coreyd97.antivirus.common.report.IReportAdapter;
import com.coreyd97.antivirus.common.report.Report;
import com.coreyd97.antivirus.common.report.ResultsReport;
import com.coreyd97.antivirus.common.report.ScanReport;
import com.coreyd97.antivirus.common.taskscheduler.TrainTask;
import com.coreyd97.antivirus.common.utils.Utils;
import com.coreyd97.antivirus.server.AntiVirusServer;
import com.coreyd97.antivirus.server.DatabaseEngine;
import com.coreyd97.antivirus.server.engine.RulesAnalysisModule;
import com.coreyd97.antivirus.server.engine.UnknownModuleException;
import com.coreyd97.c45.C45;
import com.coreyd97.c45.DataElement;
import com.coreyd97.c45.Feature;
import com.coreyd97.c45.TreeNode;
import com.google.gson.*;

import java.io.*;
import java.net.Socket;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.UUID;
import java.util.logging.Logger;

public class ClientConnection extends Thread {
    final ServerNetworkController serverNetworkController;
    final Socket socket;


    public ClientConnection(ServerNetworkController serverNetworkController, Socket clientSocket){
        this.serverNetworkController = serverNetworkController;
        this.socket = clientSocket;
    }

    @Override
    public void run() {
        BufferedReader bufferedReader;
        PrintWriter outputStream;

        try{
            bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            outputStream = new PrintWriter(socket.getOutputStream(), true);
        } catch (IOException e) {
            for (NetworkListener networkListener : serverNetworkController.getListeners()) {
                networkListener.onNetworkError((ClientNetworkException) e);
            }
            return;
        }

        String line;
        while(!this.socket.isClosed()){
            try{
                line = bufferedReader.readLine();
//                Logger.getLogger("NETWORK").info("Received: " + line);
                switch(line){
                    case "Identify": {
                        outputStream.println("CerberusAVServer");
                        this.socket.close();
                        break;
                    }
                    case "Analyse": {
                        JsonParser jsonParser = new JsonParser();
                        line = bufferedReader.readLine();
                        try{
                            JsonObject jsonObject = (JsonObject) jsonParser.parse(line);
                            if(jsonObject.get("type").getAsString().equals("ScanReport")){
                                ScanReport scanReport = new Gson().fromJson(line,ScanReport.class);

                                //Submit for analysis
                                Logger.getLogger("ANALYSIS").info("Scan Report Received - " + scanReport.getUUID());
                                AntiVirusServer.getInstance().getAnalysisManager().requestAnalysis(scanReport);
                                outputStream.println("ACCEPT " + scanReport.getUUID());
                            }else{
                                outputStream.println("DENY The submitted scanReport was not a ScanReport!");
                            }
                        }catch (JsonParseException parseException){
                            outputStream.println("DENY Could not parse the received ScanReport!");
                        } catch (UnknownModuleException moduleException) {
                            outputStream.println("DENY " + moduleException.getMessage());
                        }
                        this.socket.close();
                        break;
                    }
                    case "Results": {
                        while (!(line = bufferedReader.readLine()).equals("END")) {
                            UUID uuid = UUID.fromString(line);
                            ResultsReport resultsReport = AntiVirusServer.getInstance().getAnalysisManager().getReport(uuid);
                            if (resultsReport == null) {
                                outputStream.println("PENDING");
//                            } else if(resultsReport.getFoundMalware().size() == 0) {
//                                outputStream.println("CLEAN");
                            } else {
                                Gson gson = new GsonBuilder().registerTypeAdapter(Report.class, new IReportAdapter()).create();
                                outputStream.println(gson.toJson(resultsReport, Report.class));
                            }
                        }
                        this.socket.close();
                        break;
                    }
                    case "Train": {
                        line = bufferedReader.readLine();
                        if(!line.equalsIgnoreCase("CLEAN") && !line.equalsIgnoreCase("DIRTY")){
                            outputStream.println(line + " is invalid. Must be either CLEAN or DIRTY");
                            this.socket.close();
                            break;
                        }
                        String filePath = bufferedReader.readLine();
                        File file = new File(filePath);
                        if(!file.exists()){
                            outputStream.println(filePath + " Does not exist.");
                            this.socket.close();
                            break;
                        }
                        Utils.FileStatus status = line.equalsIgnoreCase("clean") ? Utils.FileStatus.CLEAN : Utils.FileStatus.MALWARE;
                        TrainTask task = AntiVirusServer.getInstance().getAnalysisManager().getAnalysisModule(RulesAnalysisModule.engineName).train(status, new File[]{file});
                        task.setCallback(new Runnable() {
                            @Override
                            public void run() {
                                System.out.println("Dirty Training Complete - Success:" + task.getReport().trainedSamples + " - Failed:" + task.getReport().failedSamples);
                            }
                        });
//
                        AntiVirusServer.getInstance().getTaskScheduler().submit(task);
                        this.socket.close();
                        break;
                    }

                    case "BUILDYARATREE": {
                        C45 c45 = new C45("CLEAN", "MALWARE", 5);
                        HashMap<Integer, DataElement> dataElements = new HashMap<>();
                        HashMap<String, Feature> features = new HashMap<>();

                        String selectRuleNames = "SELECT RuleName From YaraRules";
                        String selectSamples = "(SELECT ID, MALWARE FROM SAMPLES)";
                        String selectRuleMatches = "(SELECT SAMPLEID,RULENAME FROM SAMPLES INNER JOIN YARAMATCHES ON SAMPLES.ID = YARAMATCHES.SAMPLEID INNER JOIN YARARULES ON YARAMATCHES.RULEID = YARARULES.ID ORDER BY SAMPLEID)";

                        try {
                            Statement stmt = DatabaseEngine.getInstance().getConnection().createStatement();
                            ResultSet rs = stmt.executeQuery(selectRuleNames);
                            while(rs.next()){
                                String rulename = rs.getString(1);
                                Feature f = new Feature(rulename, Arrays.asList(new String[]{"true", "false"}));
                                features.put(f.name, f);
                            }

                            rs = stmt.executeQuery(selectSamples);
                            while(rs.next()){
                                int id = rs.getInt(1);
                                String classification = rs.getBoolean(2) ? "MALWARE" : "CLEAN";
                                HashMap<String, String> elementFeatures = new HashMap<>();
                                for (Feature feature : features.values()){
                                    elementFeatures.put(feature.name, "false");
                                }
                                DataElement elem = new DataElement(classification, elementFeatures, null);
                                dataElements.put(id, elem);
                            }

                            rs = stmt.executeQuery(selectRuleMatches);
                            while (rs.next()){
                                int sampleID = rs.getInt(1);
                                String ruleName = rs.getString(2);
                                dataElements.get(sampleID).features.put(ruleName, "true");
                            }

                            c45.addFeatures(new ArrayList<>(features.values()));
                            c45.addTrainingElements(new ArrayList<>(dataElements.values()));
                            c45.createTree();
                            c45.root.print();

                            Gson gson = new Gson();
                            String tree = gson.toJson(c45.root);
                            File ruleTree = new File("./config/yaraRuleTree");
                            PrintWriter writer = new PrintWriter(new FileWriter(ruleTree));
                            writer.println(tree);
                            writer.flush();
                            writer.close();
                        } catch (SQLException e) {
                            e.printStackTrace();
                        }

                        this.socket.close();
                        break;
                    }

                    case "YARATREE": {
                        File treeFile = new File("./config/yaraRuleTree");
                        try {
                            TreeNode decisionTree = new Gson().fromJson(new FileReader(treeFile), TreeNode.class);
                            decisionTree.print();
                        } catch (FileNotFoundException e) {
                            e.printStackTrace();
                            //TODO handle missing decision tree.
                            //TODO Add ability for server to report errors to client w/r processing reports.
                        }
                        this.socket.close();
                        break;
                    }

                    case "IMPORTTREE": {
                        File treeFile = new File("./config/importRuleTree");
                        try {
                            TreeNode decisionTree = new Gson().fromJson(new FileReader(treeFile), TreeNode.class);
                            decisionTree.print();
                        } catch (FileNotFoundException e) {
                            e.printStackTrace();
                            //TODO handle missing decision tree.
                            //TODO Add ability for server to report errors to client w/r processing reports.
                        }
                        this.socket.close();
                        break;
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }



    public static class ClientNetworkException extends IOException{}
}