package com.coreyd97.antivirus.server.engine;

import com.coreyd97.antivirus.common.report.*;
import com.coreyd97.antivirus.common.taskscheduler.AnalysisTask;
import com.coreyd97.antivirus.common.taskscheduler.TrainTask;
import com.coreyd97.antivirus.common.utils.ScannerEngineUtils;
import com.coreyd97.antivirus.server.AntiVirusServer;
import com.coreyd97.antivirus.server.DatabaseEngine;
import com.coreyd97.antivirus.common.utils.Utils;
import com.coreyd97.antivirus.common.report.ScanReport;
import com.github.plusvic.yara.*;
import com.github.plusvic.yara.embedded.YaraLibrary;

import java.io.*;
import java.sql.*;
import java.util.*;
import java.util.logging.Logger;

public class RulesAnalysisModule extends AnalysisModule {
    public static final String engineName = "Yara Rule Engine";
    private YaraLibrary library;
    private YaraCompiler compiler;
    private Yara yara;
    private DatabaseEngine db;
    private boolean isSetup;

    public RulesAnalysisModule() {
        super(engineName, true);
    }

    public void setup(DatabaseEngine db){
        this.yara = YaraFactory.create(YaraFactory.Mode.EMBEDDED);
        this.compiler = yara.createCompiler();
        this.db = db;

        String createRulesTable = "CREATE TABLE IF NOT EXISTS YaraRules(RuleName CHAR(64) PRIMARY KEY, Clean INT, Dirty INT)";
        Connection conn = db.getConnection();
        try {
            Statement statement = conn.createStatement();
            statement.executeUpdate(createRulesTable);
        } catch (SQLException e) {}

        ScannerEngineUtils.RuleImportTask ruleImportTask = new ScannerEngineUtils.RuleImportTask(new File[]{new File("config/rules/index.yar")}, this, yara, compiler);
        ruleImportTask.run();
        isSetup = true;
    }

    private void setup() {
        this.setup(AntiVirusServer.getInstance().getDatabaseEngine());
    }

    private void addRuleMatch(String rulename, Utils.FileStatus fileStatus) throws SQLException {
        Connection connection = db.getConnection();
        PreparedStatement stmt;
        //Function exists
        String ruleUpdate;
        if(fileStatus == Utils.FileStatus.CLEAN){
            ruleUpdate = "UPDATE YaraRules Set CLEAN=CLEAN+1 WHERE RuleName=?";
        }else{
            ruleUpdate = "UPDATE YaraRules Set DIRTY=DIRTY+1 WHERE RuleName=?";
        }
        stmt = connection.prepareStatement(ruleUpdate);
        stmt.setString(1, rulename);
        int updated = stmt.executeUpdate();
        if(updated == 0) {
            //Function does not yet exist
            String ruleInsert = "INSERT INTO YaraRules VALUES (?, ?, ?)";
            stmt = connection.prepareStatement(ruleInsert, Statement.RETURN_GENERATED_KEYS);
            stmt.setString(1, rulename);
            stmt.setInt(2, fileStatus == Utils.FileStatus.CLEAN ? 1 : 0);
            stmt.setInt(3, fileStatus == Utils.FileStatus.MALWARE ? 1 : 0);
            stmt.executeUpdate();
            ResultSet results = stmt.getGeneratedKeys();
            if(!results.next()){
                throw new SQLException("Function entry was not inserted!");
            }
        }
    }


    @Override
    public TrainTask train(Utils.FileStatus fileStatus, File[] files) {
        RuleTrainTask trainTask = new RuleTrainTask("Yara Rule Training", files, fileStatus);
        return trainTask;
    }

    @Override
    public AnalysisTask processReport(ScanReport scanReport) {
        AnalysisTask analysisTask = new RuleAnalysisTask("Yara Rule Analysis", scanReport);
        return analysisTask;
    }

    private class RuleAnalysisTask extends AnalysisTask {

        protected RuleAnalysisTask(String taskName, ScanReport report) {
            super(taskName, report);
        }

        @Override
        public void processFile(FileFeatures fileFeatures) throws SQLException {
            //TODO Cache calculated scores.
            float total = 0;
            for (String ruleName : ((List<String>) fileFeatures.featureList)) {
                total += calculateScore(ruleName);
            }

            if(total < 0) {
                resultsReport.addMalware(new MalwareEntry(fileFeatures.filePath, -total*100, ""));
            }
        }

        @Override
        public void run() {
            if(!RulesAnalysisModule.this.isSetup){
                setup();
            }
            super.run();
        }
    }

    private class RuleTrainTask extends TrainTask {
        Utils.FileStatus fileStatus;
        YaraScanner scanner;
        int trainedCount = 0;
        HashMap<String, ArrayList<String>> ruleMatches;
        ArrayList<String> scannedFiles;
        File active;

        protected RuleTrainTask(String taskName, File[] files, Utils.FileStatus fileStatus) {
            super(taskName, files, RulesAnalysisModule.this);
            this.fileStatus = fileStatus;
            ruleMatches = new HashMap<>();
            scannedFiles = new ArrayList<>();
        }

        @Override
        protected void processFile(File file) {
            trainedCount++;
            active = file;
            try {
                scanner.scan(file);
                scannedFiles.add(file.getName());
                this.report.trainedSamples++;
            }catch (YaraException e){
                this.report.failedSamples++;
            }
        }

        @Override
        public void run() {
            if(!RulesAnalysisModule.this.isSetup){
                setup();
            }
            YaraScanCallback scanCallback = new YaraScanCallback() {
                @Override
                public void onMatch(YaraRule yaraRule) {
//                    try {
//                        addRuleMatch(yaraRule.getIdentifier(), fileStatus);
                        if (!ruleMatches.containsKey(yaraRule.getIdentifier())) {
                            ruleMatches.put(yaraRule.getIdentifier(), new ArrayList<>());
                        }
                        ruleMatches.get(yaraRule.getIdentifier()).add(active.getName());

//                    } catch (SQLException e) {}
                }
            };
            scanner = compiler.createScanner();
            scanner.setCallback(scanCallback);
            super.run();

            //Print to file
            File names = new File("./config/training.names");
            try {
                PrintWriter writer = new PrintWriter(new FileWriter(names));
                writer.println("Malware, Clean.");
                for (String s : ruleMatches.keySet()) {
                    writer.println(s + ": true, false.");
                    writer.flush();
                }
                writer.close();
            } catch (IOException e) {
                e.printStackTrace();
            }

            File data = new File("./config/training.data");
            try {
                PrintWriter writer = new PrintWriter(new FileWriter(data));
                for(String file : scannedFiles) {
                    for (String s : ruleMatches.keySet()) {
                        writer.print(ruleMatches.get(s).contains(file) + ", ");
                    }
                    writer.println(Math.random() <= 0.5 ? "Malware" : "Clean");
                    writer.flush();
                }
                writer.close();
            } catch (IOException e) {
                e.printStackTrace();
            }

//            try {
//                db.addTrainedCount(RulesAnalysisModule.engineName, trainedCount, this.fileStatus);
//            } catch (SQLException e) {
//                Logger.getAnonymousLogger().warning("Total trained sample count could not be updated! Please execute manually to maintain accuracy of the system.");
//                try {
//                    Logger.getAnonymousLogger().warning(db.getTrainedCountManualQuery(RulesAnalysisModule.engineName, trainedCount, this.fileStatus));
//                } catch (SQLException e1) {
//                    e.printStackTrace();
//                }
//            }
//            yara.finalizeThread();
        }
    }
//private class RuleTrainTask extends TrainTask {
//        Utils.FileStatus fileStatus;
//        YaraScanner scanner;
//        int trainedCount = 0;
//
//        protected RuleTrainTask(String taskName, File[] files, Utils.FileStatus fileStatus) {
//            super(taskName, files, RulesAnalysisModule.this);
//            this.fileStatus = fileStatus;
//        }
//
//        @Override
//        protected void processFile(File file) {
//            trainedCount++;
//            try {
//                scanner.scan(file);
//                this.report.trainedSamples++;
//            }catch (YaraException e){
//                this.report.failedSamples++;
//            }
//        }
//
//        @Override
//        public void run() {
//            if(!RulesAnalysisModule.this.isSetup){
//                setup();
//            }
//            YaraScanCallback scanCallback = new YaraScanCallback() {
//                @Override
//                public void onMatch(YaraRule yaraRule) {
//                    try {
//                        addRuleMatch(yaraRule.getIdentifier(), fileStatus);
//                    } catch (SQLException e) {}
//                }
//            };
//            scanner = compiler.createScanner();
//            scanner.setCallback(scanCallback);
//            super.run();
//            try {
//                db.addTrainedCount(RulesAnalysisModule.engineName, trainedCount, this.fileStatus);
//            } catch (SQLException e) {
//                Logger.getAnonymousLogger().warning("Total trained sample count could not be updated! Please execute manually to maintain accuracy of the system.");
//                try {
//                    Logger.getAnonymousLogger().warning(db.getTrainedCountManualQuery(RulesAnalysisModule.engineName, trainedCount, this.fileStatus));
//                } catch (SQLException e1) {
//                    e.printStackTrace();
//                }
//            }
//            yara.finalizeThread();
//        }
//    }


    private float calculateScore(String ruleName) throws SQLException {
        int dirtyCount, cleanCount, totalClean, totalDirty;
        PreparedStatement stmt = null;
        try {
            stmt = db.getConnection().prepareStatement("SELECT * FROM YARARULES WHERE RULENAME=? LIMIT 1");
            stmt.setString(1, ruleName);
            ResultSet results = stmt.executeQuery();
            if(results.next()){
                dirtyCount = results.getInt("DIRTY");
                cleanCount = results.getInt("CLEAN");
            }else{
                return 0; //Rule has not had hits when training.
            }

            stmt = db.getConnection().prepareStatement("SELECT * FROM TRAINING WHERE MODULE=? LIMIT 1");
            stmt.setString(1, RulesAnalysisModule.engineName);
            results = stmt.executeQuery();
            if(results.next()) {
                totalClean = results.getInt("CleanSamples");
                totalDirty = results.getInt("MalwareSamples");
            }else{
                //No training has been carried out.
                return 0;
            }
            if(totalClean == 0 || totalDirty == 0) return 0;
            return 0;

        }catch(SQLException e){
            return 0;
        }
    }

}
