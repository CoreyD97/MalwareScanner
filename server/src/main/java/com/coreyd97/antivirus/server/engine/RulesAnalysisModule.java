package com.coreyd97.antivirus.server.engine;

import com.coreyd97.antivirus.common.report.*;
import com.coreyd97.antivirus.common.taskscheduler.AnalysisTask;
import com.coreyd97.antivirus.common.utils.ScannerEngineUtils;
import com.coreyd97.antivirus.server.AntiVirusServer;
import com.coreyd97.antivirus.server.DatabaseEngine;
import com.coreyd97.antivirus.common.utils.Utils;
import com.coreyd97.antivirus.common.report.ScanReport;
import com.coreyd97.antivirus.common.taskscheduler.FileTask;
import com.github.plusvic.yara.*;
import com.github.plusvic.yara.embedded.YaraLibrary;

import java.io.File;
import java.sql.*;

public class RulesAnalysisModule extends AnalysisModule {
    public static final String engineName = "Yara Rule Engine";
    private YaraLibrary library;
    private YaraCompiler compiler;
    private Yara yara;
    private DatabaseEngine db;
    private boolean setupComplete;

    public RulesAnalysisModule() {
        super(engineName, true);
    }

    private void setup() {
        this.yara = YaraFactory.create(YaraFactory.Mode.EMBEDDED);
        this.compiler = yara.createCompiler();
        this.db = AntiVirusServer.getInstance().getDatabaseEngine();

        String createRulesTable = "CREATE TABLE IF NOT EXISTS YaraRules(RuleName CHAR(64) PRIMARY KEY, Clean INT, Dirty INT)";
        Connection conn = db.getConnection();
        try {
            Statement statement = conn.createStatement();
            statement.executeUpdate(createRulesTable);
        } catch (SQLException e) {}


            generateRuleImportTask(new File[]{new File("config/rules/index.yar")}).call();
            this.setupComplete = true;
    }

    private void addRuleMatch(String rulename, Utils.FileStatus fileStatus) throws SQLException {
        Connection connection = db.getConnection();
        PreparedStatement stmt;
        //Function exists
        String ruleUpdate = "UPDATE YaraRules Set " + fileStatus + "=" + fileStatus + "+1 WHERE RuleName=?";
        stmt = connection.prepareStatement(ruleUpdate);
        stmt.setString(1, rulename);
        int updated = stmt.executeUpdate();
        if(updated == 0) {
            //Function does not yet exist
            String ruleInsert = "INSERT INTO YaraRules VALUES (?, ?, ?)";
            stmt = connection.prepareStatement(ruleInsert, Statement.RETURN_GENERATED_KEYS);
            stmt.setString(1, rulename);
            stmt.setInt(2, fileStatus == Utils.FileStatus.CLEAN ? 1 : 0);
            stmt.setInt(3, fileStatus == Utils.FileStatus.DIRTY ? 1 : 0);
            stmt.executeUpdate();
            ResultSet results = stmt.getGeneratedKeys();
            if(!results.next()){
                throw new SQLException("Function entry was not inserted!");
            }
        }
    }


    @Override
    public FileTask train(Utils.FileStatus fileStatus, File[] files) {
        RuleTrainTask trainTask = new RuleTrainTask("Yara Rule Training", files, fileStatus, new TrainReport(this));
        return trainTask;
    }

    @Override
    public AnalysisTask processReport(ScanReport scanReport) {
        AnalysisTask analysisTask = new RuleAnalysisTask("Yara Rule Analysis", scanReport);
        return analysisTask;
    }

    private class RuleAnalysisTask extends AnalysisTask {

        protected RuleAnalysisTask(String taskName, ScanReport report) {
            super(taskName, report);
            //TODO Better setup. Don't setup only when needed.
            if(!RulesAnalysisModule.this.setupComplete){
                setup();
            }
        }

        @Override
        public void processFile(FileFeatures fileFeatures) throws SQLException {
            Utils.HashType hashType = Utils.HashType.valueOf((String) fileFeatures.featureMap.get("HashType"));
            String hash = (String) fileFeatures.featureMap.get(fileFeatures.featureMap.get("HashType"));
            if(db.containsSample(fileFeatures.fileSize, hashType, hash)){
                resultsReport.addMalware(new MalwareEntry(fileFeatures.filePath, 100, "Matched existing hash"));
            }
        }
    }

    private class RuleTrainTask extends FileTask {
        Utils.FileStatus fileStatus;
        YaraScanner scanner;

        protected RuleTrainTask(String taskName, File[] files, Utils.FileStatus fileStatus, TrainReport trainReport) {
            super(taskName, files, trainReport);
            this.fileStatus = fileStatus;
            //TODO Better setup. Don't setup only when needed.
            if(!RulesAnalysisModule.this.setupComplete){
                setup();
            }
        }

        @Override
        protected void processFile(File file) {
            try {
                addRuleMatch("TOTALTRAINEDSAMPLES", fileStatus);
            } catch (SQLException e) {}
            try {
                scanner.scan(file);
            }catch (YaraException e){}
        }

        @Override
        public Report call() {
            YaraScanCallback scanCallback = new YaraScanCallback() {
                @Override
                public void onMatch(YaraRule yaraRule) {
                    try {
                        addRuleMatch(yaraRule.getIdentifier(), fileStatus);
                    } catch (SQLException e) {}
                }
            };
            scanner = compiler.createScanner();
            scanner.setCallback(scanCallback);
            Report report = super.call();
            yara.finalizeThread();
            return report;
        }
    }

    private ScannerEngineUtils.RuleImportTask generateRuleImportTask(File[] files){
        ScannerEngineUtils.RuleImportTask task = new ScannerEngineUtils.RuleImportTask(files, new TrainReport(this), yara, compiler);
        return task;
    }


}
