package com.coreyd97.antivirus.server.engine;

import com.coreyd97.antivirus.common.engine.YaraManager;
import com.coreyd97.antivirus.common.report.Explanation;
import com.coreyd97.antivirus.common.report.FileFeatures;
import com.coreyd97.antivirus.common.report.MalwareEntry;
import com.coreyd97.antivirus.common.report.ScanReport;
import com.coreyd97.antivirus.common.stats.StatProvider;
import com.coreyd97.antivirus.common.taskscheduler.AnalysisTask;
import com.coreyd97.antivirus.common.taskscheduler.TrainTask;
import com.coreyd97.antivirus.common.utils.Utils;
import com.coreyd97.antivirus.server.DatabaseEngine;
import com.coreyd97.antivirus.server.taskscheduler.ExplainTask;
import com.coreyd97.c45.C45;
import com.coreyd97.c45.DataElement;
import com.coreyd97.c45.Feature;
import com.coreyd97.c45.TreeNode;
import com.github.plusvic.yara.YaraException;
import com.github.plusvic.yara.YaraRule;
import com.github.plusvic.yara.YaraScanner;
import com.google.gson.Gson;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.io.*;
import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.logging.Logger;

public class RulesAnalysisModule extends AnalysisModule implements StatProvider {
    public static final String engineName = "Yara Rule Engine";
    private int moduleID;

    private DatabaseEngine database;
    private YaraManager yaraManager;

    //Classification Variables
    private TreeNode decisionTree;

    public RulesAnalysisModule(AnalysisManager analysisManager) {
        super(engineName, true);
        this.database = analysisManager.getDatabaseEngine();
        this.yaraManager = analysisManager.getYaraManager();

        createTables();
        loadTree();
    }

    private void createTables(){
        String createRulesTable = "CREATE TABLE IF NOT EXISTS YaraRules(ID int AUTO_INCREMENT PRIMARY KEY, RuleName VARCHAR)";
        String createMatchTable = "CREATE TABLE IF NOT EXISTS YaraMatches(RuleID INT, SampleID INT, PRIMARY KEY(RuleID, SampleID), FOREIGN KEY (RuleID) REFERENCES YARARULES(ID) ON DELETE CASCADE ON UPDATE CASCADE, FOREIGN KEY (SampleID) REFERENCES SAMPLES(ID) ON DELETE CASCADE ON UPDATE CASCADE)";
        Connection conn = database.getConnection(this);
        try {
            Statement statement = conn.createStatement();
            statement.executeUpdate(createRulesTable);
            statement.executeUpdate(createMatchTable);
            this.moduleID = DatabaseEngine.registerModule(conn, RulesAnalysisModule.engineName);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        database.releaseConnection(conn);
    }

    private void loadTree(){
        File treeFile = new File("./config/yaraRuleTree");
        try {
            decisionTree = new Gson().fromJson(new FileReader(treeFile), TreeNode.class);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            //TODO handle missing decision tree.
            //TODO Add ability for server to report errors to client w/r processing reports.
        }
    }


    @Override
    public TrainTask train(Utils.FileStatus fileStatus, File[] files) {
        RuleTrainTask trainTask = new RuleTrainTask("Yara Rule Training", files, fileStatus);
        return trainTask;
    }

    @Override
    public AnalysisTask processReport(ScanReport scanReport) {
        AnalysisTask analysisTask = new RuleAnalysisTask("Yara Rule Analysis", scanReport);
        return analysisTask;
    }

    @Override
    public ExplainTask explain(ScanReport scanReport) {
        ExplainTask explainTask = new RuleExplainTask("Yara Analysis Explanation", scanReport);
        return explainTask;
    }

    private class RuleAnalysisTask extends AnalysisTask {

        protected RuleAnalysisTask(String taskName, ScanReport report) {
            super(taskName, report);
        }

        @Override
        public void processFile(FileFeatures fileFeatures) throws SQLException {
            HashMap<String, String> features = new HashMap<>();
            HashSet<String> rules = new HashSet<>();
            if(fileFeatures.featureList != null) {
                rules.addAll((ArrayList<String>) fileFeatures.featureList);
            }

            fileFeatures.featureMap.forEach((feature, value) -> {
                features.put(feature.toString(), value);
            });

            DataElement element = new DataElement(null, features, rules);
            if(decisionTree.classify(element).equalsIgnoreCase("MALWARE")) {
                resultsReport.addMalware(new MalwareEntry(fileFeatures.filePath, 0, "The matched YARA rules were similar to those used by malware."));
            }
        }
    }

    private class RuleExplainTask extends ExplainTask {

        protected RuleExplainTask(String taskName, ScanReport report) {
            super(taskName, RulesAnalysisModule.this.decisionTree, report);
        }


        @Override
        protected void processFile(FileFeatures fileFeatures) throws SQLException {
            HashMap<String, String> features = new HashMap<>();
            HashSet<String> rules = new HashSet<>();
            rules.addAll((ArrayList<String>) fileFeatures.featureList);

            fileFeatures.featureMap.forEach((feature, value) -> {
                features.put(feature.toString(), value);
            });

            DataElement element = new DataElement(null, features, rules);
            String explanation = this.explain(element);
            resultsReport.addExplanation(new Explanation(fileFeatures.filePath, explanation));
        }

        @Override
        public String getReadableAttribute(String attribute) {
            return attribute; //Attribute already readable.
        }
    }

    private class RuleTrainTask extends TrainTask {
        Utils.FileStatus fileStatus;
        YaraScanner scanner;

        protected RuleTrainTask(String taskName, File[] files, Utils.FileStatus fileStatus) {
            super(taskName, files);
            this.fileStatus = fileStatus;
            this.scanner = RulesAnalysisModule.this.yaraManager.getScanner();
        }

        @Override
        protected boolean processFile(File file){
            Connection connection = database.getConnection(this);
            try {
//                if(canTrain(file)) {
                    connection.setAutoCommit(false);
                    int sampleID = DatabaseEngine.addSampleIfNotExists(connection, file, fileStatus == Utils.FileStatus.MALWARE);
                    if (DatabaseEngine.isModuleTrained(connection, moduleID, sampleID)) {
                        //We've already trained the module on this sample.
                        result.incrementExisting();
                        database.releaseConnection(connection);
                        return true;
                    }
                    scanner.scan(file, null, yaraRule -> {
                        try {
                            int ruleID = getRuleID(connection, yaraRule);
                            addRuleMatch(connection, sampleID, ruleID);
                        } catch (SQLException e) {
                        }
                    });
                    result.incrementTrained();
                    if(fileStatus == Utils.FileStatus.MALWARE) maliciousSamples++;
                    else cleanSamples++;
                    DatabaseEngine.markSampleTrained(connection, moduleID, sampleID);
                    connection.commit();
//                }
            }catch (YaraException | SQLException | IOException e){
                result.incrementFailed();
            }finally {
                try{
                    connection.setAutoCommit(true);
                }catch (SQLException ignored){}
            }
            database.releaseConnection(connection);
            return true;
        }

        private boolean canTrain(File file){
            return true;
//            String[] suitable = new String[]{"application/x-ms-dos-executable", "application/x-msdownload"};
//            try {
//                String mime = Files.probeContentType(file.toPath());
//                for (String valid : suitable) {
//                    if(mime.equalsIgnoreCase(valid)) return true;
//                }
//                return false;
//            } catch (IOException e) {
//                return false;
//            }
        }

        @Override
        public void run() {
            super.run();
            try {
                createTree();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }


    /**
     * Finds the id for a yara rule or inserts into the table and returns the generated row id.
     * @param rule The rule to be searched for
     * @return int the identifier for the rule.
     */
    private int getRuleID(Connection connection, YaraRule rule) throws SQLException{
        PreparedStatement stmt = connection.prepareStatement("SELECT id from YARARULES WHERE RULENAME=? LIMIT 1");
        stmt.setString(1, rule.getIdentifier());
        ResultSet results = stmt.executeQuery();
        if(results.next()){
            return results.getInt(1);
        }else{
            stmt = connection.prepareStatement("INSERT INTO YARARULES VALUES (NULL, ?)", PreparedStatement.RETURN_GENERATED_KEYS);
            stmt.setString(1, rule.getIdentifier());
            stmt.executeUpdate();
            results = stmt.getGeneratedKeys();
            if(results.next()){
                uniqueRules++;
                return results.getInt(1);
            }
        }
        return -1;
    }

    private boolean addRuleMatch(Connection connection, int sampleID, int ruleID) throws SQLException{
        PreparedStatement stmt = connection.prepareStatement("INSERT INTO YARAMATCHES VALUES(?,?)");
        stmt.setInt(1, ruleID);
        stmt.setInt(2, sampleID);
        int effectedRows = stmt.executeUpdate();
        return effectedRows != 0;
    }

    private ArrayList<String> getRuleNames(Connection connection){
        Statement stmt = null;
        try {
            stmt = connection.createStatement();
            ResultSet rs = stmt.executeQuery("SELECT RuleName From YaraRules");
            ArrayList<String> rules = new ArrayList<>();
            while (rs.next()) {
                String rulename = rs.getString(1);
                Feature f = new Feature(rulename, Arrays.asList(new String[]{"true", "false"}));
                rules.add(f.name);
            }
            return rules;
        } catch (SQLException e) {
            return null;
        }
    }

    public void createTree() throws SQLException {
        C45 c45 = new C45("CLEAN", "MALWARE", 5);
        HashMap<Integer, DataElement> dataElements = new HashMap<>();
        HashMap<String, Feature> features = new HashMap<>();

        String selectRuleNames = "SELECT RuleName From YaraRules";
        //TODO Fix sample select. Only select trained samples
        String selectSamples = "(SELECT SAMPLES.ID, MALWARE, MIMETYPES.MIME FROM SAMPLES LEFT JOIN MIMETYPES ON SAMPLES.MIME = MIMETYPES.ID)";
        String selectRuleMatches = "(SELECT SAMPLEID,RULENAME FROM SAMPLES INNER JOIN YARAMATCHES ON SAMPLES.ID = YARAMATCHES.SAMPLEID INNER JOIN YARARULES ON YARAMATCHES.RULEID = YARARULES.ID ORDER BY SAMPLEID)";

        Connection connection = database.getConnection(this);
        Statement stmt = connection.createStatement();
        ResultSet rs = stmt.executeQuery(selectRuleNames);
        while (rs.next()) {
            String rulename = rs.getString(1);
            Feature f = new Feature(rulename);
            features.put(f.name, f);
        }

        //ADD Mime Type as Feature
//        features.put(FileFeatures.Feature.MIME_TYPE.toString(),
//                new Feature(FileFeatures.Feature.MIME_TYPE.toString(), database.getMimeTypes(connection)));


        rs = stmt.executeQuery(selectSamples);
        while (rs.next()) {
            int id = rs.getInt(1);
            String classification = rs.getBoolean(2) ? "MALWARE" : "CLEAN";
            String mime = rs.getString(3);
            DataElement elem = new DataElement(classification, new HashMap<>(), new HashSet<>());
            elem.features.put(FileFeatures.Feature.MIME_TYPE.toString(), mime);
            dataElements.put(id, elem);
        }

        rs = stmt.executeQuery(selectRuleMatches);
        while (rs.next()) {
            int sampleID = rs.getInt(1);
            String ruleName = rs.getString(2);
            dataElements.get(sampleID).labels.add(ruleName);
        }

        database.releaseConnection(connection);

        c45.addFeatures(new ArrayList<>(features.values()));
        c45.addTrainingElements(new ArrayList<>(dataElements.values()));

        long t = System.currentTimeMillis();
        Logger.getLogger("CREATETREE").info("Start - " + t);
        c45.createTree();
        Logger.getLogger("CREATETREE").info("End - " + ((System.currentTimeMillis() - t)/60000));

        Gson gson = new Gson();
        String tree = gson.toJson(c45.root);
        File ruleTree = new File("./config/yaraRuleTree");
        PrintWriter writer = null;
        try {
            writer = new PrintWriter(new FileWriter(ruleTree));
            writer.println(tree);
            writer.flush();
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    JPanel panel;
    JLabel lblCleanSamples, lblMaliciousSamples, lblUniqueRules, lblReady;
    int cleanSamples, maliciousSamples, uniqueRules;

    @Override
    public JPanel getStatPanel() {
        if(panel == null){
            panel = new JPanel(new GridBagLayout());
            GridBagConstraints gbc = new GridBagConstraints();
            gbc.weightx = gbc.weighty = 1.0;
            gbc.gridx = gbc.gridy = 1;
            gbc.fill = GridBagConstraints.BOTH;
            TitledBorder border = BorderFactory.createTitledBorder("Yara Rule Analytics");
            border.setTitleColor(Color.BLUE);
            panel.setBorder(border);

            lblCleanSamples = new JLabel();
            lblMaliciousSamples = new JLabel();
            lblUniqueRules = new JLabel();
            lblReady = new JLabel();

            Connection connection = database.getConnection(this);
            HashMap<Boolean, Integer> trainedCount = (HashMap<Boolean, Integer>) database.getModuleTrainedCount(connection, this.moduleID);
            database.releaseConnection(connection);

            cleanSamples = trainedCount.get(false);
            maliciousSamples = trainedCount.get(true);
            connection = database.getConnection(this);
            uniqueRules = getRuleNames(connection).size();
            this.database.releaseConnection(connection);


            panel.add(lblCleanSamples, gbc);
            gbc.gridy++;
            panel.add(lblMaliciousSamples, gbc);
            gbc.gridy=1;
            gbc.gridx++;
            panel.add(lblUniqueRules, gbc);

            gbc.gridx = 1;
            gbc.gridwidth = 2;
            gbc.gridy = 10;
            panel.add(lblReady, gbc);
        }

        int cleanPercent = (int) Math.round((((double) cleanSamples)/(cleanSamples+maliciousSamples))*100);
        int malwarePercent = (int) Math.round((((double) maliciousSamples)/(cleanSamples+maliciousSamples))*100);
        lblCleanSamples.setText(String.format("Clean Samples Trained: %d (%d%%)", cleanSamples, cleanPercent));
        lblMaliciousSamples.setText(String.format("Malicious Samples Trained: %d (%d%%)", maliciousSamples, malwarePercent));
        lblUniqueRules.setText(String.format("Unique Rules Matched: %d", uniqueRules));
        lblReady.setText("Ready to Classify: " + (this.decisionTree == null ? "FALSE" : "TRUE"));
        return panel;
    }
}
