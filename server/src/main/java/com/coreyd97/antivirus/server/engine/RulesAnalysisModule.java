package com.coreyd97.antivirus.server.engine;

import com.coreyd97.antivirus.common.report.*;
import com.coreyd97.antivirus.common.taskscheduler.AnalysisTask;
import com.coreyd97.antivirus.common.taskscheduler.TrainTask;
import com.coreyd97.antivirus.common.utils.ScannerEngineUtils;
import com.coreyd97.antivirus.server.AntiVirusServer;
import com.coreyd97.antivirus.server.DatabaseEngine;
import com.coreyd97.antivirus.common.utils.Utils;
import com.coreyd97.antivirus.common.report.ScanReport;
import com.github.plusvic.yara.*;
import com.github.plusvic.yara.embedded.YaraLibrary;

import java.io.File;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

public class RulesAnalysisModule extends AnalysisModule {
    public static final String engineName = "Yara Rule Engine";
    private YaraLibrary library;
    private YaraCompiler compiler;
    private Yara yara;
    private DatabaseEngine db;
    private boolean setupComplete;

    public RulesAnalysisModule() {
        super(engineName, true);
    }

    public void setup(DatabaseEngine db){
        this.yara = YaraFactory.create(YaraFactory.Mode.EMBEDDED);
        this.compiler = yara.createCompiler();
        this.db = db;

        String createRulesTable = "CREATE TABLE IF NOT EXISTS YaraRules(RuleName CHAR(64) PRIMARY KEY, Clean INT, Dirty INT)";
        Connection conn = db.getConnection();
        try {
            Statement statement = conn.createStatement();
            statement.executeUpdate(createRulesTable);
        } catch (SQLException e) {}

        ScannerEngineUtils.RuleImportTask ruleImportTask = generateRuleImportTask(new File[]{new File("config/rules/index.yar")});
        ruleImportTask.setCallback(new Runnable() {
            @Override
            public void run() {
                RulesAnalysisModule.this.setupComplete = true;
            }
        });
        AntiVirusServer.getInstance().getTaskScheduler().submitFutureTask(ruleImportTask, true);

    }

    private void setup() {
        this.setup(AntiVirusServer.getInstance().getDatabaseEngine());
    }

    private void addRuleMatch(String rulename, Utils.FileStatus fileStatus) throws SQLException {
        Connection connection = db.getConnection();
        PreparedStatement stmt;
        //Function exists
        String ruleUpdate;
        if(fileStatus == Utils.FileStatus.CLEAN){
            ruleUpdate = "UPDATE YaraRules Set CLEAN=CLEAN+1 WHERE RuleName=?";
        }else{
            ruleUpdate = "UPDATE YaraRules Set DIRTY=DIRTY+1 WHERE RuleName=?";
        }
        stmt = connection.prepareStatement(ruleUpdate);
        stmt.setString(1, rulename);
        int updated = stmt.executeUpdate();
        if(updated == 0) {
            //Function does not yet exist
            String ruleInsert = "INSERT INTO YaraRules VALUES (?, ?, ?)";
            stmt = connection.prepareStatement(ruleInsert, Statement.RETURN_GENERATED_KEYS);
            stmt.setString(1, rulename);
            stmt.setInt(2, fileStatus == Utils.FileStatus.CLEAN ? 1 : 0);
            stmt.setInt(3, fileStatus == Utils.FileStatus.MALWARE ? 1 : 0);
            stmt.executeUpdate();
            ResultSet results = stmt.getGeneratedKeys();
            if(!results.next()){
                throw new SQLException("Function entry was not inserted!");
            }
        }
    }


    @Override
    public TrainTask train(Utils.FileStatus fileStatus, File[] files) {
        RuleTrainTask trainTask = new RuleTrainTask("Yara Rule Training", files, fileStatus);
        return trainTask;
    }

    @Override
    public AnalysisTask processReport(ScanReport scanReport) {
        AnalysisTask analysisTask = new RuleAnalysisTask("Yara Rule Analysis", scanReport);
        return analysisTask;
    }

    private class RuleAnalysisTask extends AnalysisTask {

        protected RuleAnalysisTask(String taskName, ScanReport report) {
            super(taskName, report);
            //TODO Better setup. Don't setup only when needed.
            if(!RulesAnalysisModule.this.setupComplete){
                setup();
            }
        }

        @Override
        public void processFile(FileFeatures fileFeatures) throws SQLException {
            //TODO Cache calculated scores.
            float total = 0;
            for (String ruleName : ((List<String>) fileFeatures.featureList)) {
                total += calculateScore(ruleName);
            }
            if(total < 0) {
                resultsReport.addMalware(new MalwareEntry(fileFeatures.filePath, -total*100, ""));
            }
        }

        @Override
        public void run() {
            while(!RulesAnalysisModule.this.setupComplete){
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {}
            }
            super.run();
        }
    }

    private class RuleTrainTask extends TrainTask {
        Utils.FileStatus fileStatus;
        YaraScanner scanner;
        int trainedCount = 0;

        protected RuleTrainTask(String taskName, File[] files, Utils.FileStatus fileStatus) {
            super(taskName, files, RulesAnalysisModule.this);
            this.fileStatus = fileStatus;
            //TODO Better setup. Don't setup only when needed.
            if(!RulesAnalysisModule.this.setupComplete){
                setup();
            }
        }

        @Override
        protected void processFile(File file) {
            trainedCount++;
            try {
                scanner.scan(file);
                this.report.trainedSamples++;
            }catch (YaraException e){
                this.report.failedSamples++;
            }
        }

        @Override
        public void run() {
            while(!RulesAnalysisModule.this.setupComplete){
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {}
            }
            YaraScanCallback scanCallback = new YaraScanCallback() {
                @Override
                public void onMatch(YaraRule yaraRule) {
                    try {
                        addRuleMatch(yaraRule.getIdentifier(), fileStatus);
                    } catch (SQLException e) {}
                }
            };
            scanner = compiler.createScanner();
            scanner.setCallback(scanCallback);
            super.run();
            try {
                db.addTrainedCount(RulesAnalysisModule.engineName, trainedCount, this.fileStatus);
            } catch (SQLException e) {
                Logger.getAnonymousLogger().warning("Total trained sample count could not be updated! Please execute manually to maintain accuracy of the system.");
                try {
                    Logger.getAnonymousLogger().warning(db.getTrainedCountManualQuery(RulesAnalysisModule.engineName, trainedCount, this.fileStatus));
                } catch (SQLException e1) {
                    e.printStackTrace();
                }
            }
            yara.finalizeThread();
        }
    }

    private ScannerEngineUtils.RuleImportTask generateRuleImportTask(File[] files){
        ScannerEngineUtils.RuleImportTask task = new ScannerEngineUtils.RuleImportTask(files, RulesAnalysisModule.this, yara, compiler);
        return task;
    }

    private float calculateScore(String ruleName) throws SQLException {
        int dirtyCount, cleanCount, totalClean, totalDirty;
        PreparedStatement stmt = null;
        try {
            stmt = db.getConnection().prepareStatement("SELECT * FROM YARARULES WHERE RULENAME=? LIMIT 1");
            stmt.setString(1, ruleName);
            ResultSet results = stmt.executeQuery();
            if(results.next()){
                dirtyCount = results.getInt("DIRTY");
                cleanCount = results.getInt("CLEAN");
            }else{
                return 0; //Rule has not had hits when training.
            }

            stmt = db.getConnection().prepareStatement("SELECT * FROM TRAINING WHERE MODULE=? LIMIT 1");
            stmt.setString(1, RulesAnalysisModule.engineName);
            results = stmt.executeQuery();
            if(results.next()) {
                totalClean = results.getInt("CleanSamples");
                totalDirty = results.getInt("MalwareSamples");
            }else{
                //No training has been carried out.
                return 0;
            }
            if(totalClean == 0 || totalDirty == 0) return 0;
            return ((float)cleanCount/totalClean)-((float)dirtyCount/totalDirty);

        }catch(SQLException e){
            return 0;
        }
    }

}
