package com.coreyd97.antivirus.server.engine;

import com.coreyd97.antivirus.common.report.FileFeatures;
import com.coreyd97.antivirus.common.report.MalwareEntry;
import com.coreyd97.antivirus.common.report.ScanReport;
import com.coreyd97.antivirus.common.taskscheduler.AnalysisTask;
import com.coreyd97.antivirus.common.taskscheduler.TrainTask;
import com.coreyd97.antivirus.common.utils.ScannerEngineUtils;
import com.coreyd97.antivirus.common.utils.Utils;
import com.coreyd97.antivirus.server.AntiVirusServer;
import com.coreyd97.antivirus.server.DatabaseEngine;
import com.coreyd97.antivirus.server.ui.StatProvider;
import com.coreyd97.c45.C45;
import com.coreyd97.c45.DataElement;
import com.coreyd97.c45.Feature;
import com.coreyd97.c45.TreeNode;
import com.github.plusvic.yara.*;
import com.github.plusvic.yara.embedded.YaraLibrary;
import com.google.gson.Gson;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.io.*;
import java.nio.file.Files;
import java.sql.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;

public class RulesAnalysisModule extends AnalysisModule implements StatProvider {
    public static final String engineName = "Yara Rule Engine";
    private int moduleID;
    private YaraLibrary library;
    private YaraCompiler compiler;
    private Yara yara;
    private DatabaseEngine db;
    private boolean isSetup;

    //Classification Variables
    private TreeNode decisionTree;
    private ArrayList<String> trainedRules;

    public RulesAnalysisModule() {
        super(engineName, true);
        trainedRules = new ArrayList<>();
    }

    void setup(DatabaseEngine db){
        this.yara = YaraFactory.create(YaraFactory.Mode.EMBEDDED);
        this.compiler = yara.createCompiler();
        this.db = db;

        String createRulesTable = "CREATE TABLE IF NOT EXISTS YaraRules(ID int AUTO_INCREMENT PRIMARY KEY, RuleName VARCHAR)";
        String createMatchTable = "CREATE TABLE IF NOT EXISTS YaraMatches(RuleID INT, SampleID INT, PRIMARY KEY(RuleID, SampleID), FOREIGN KEY (RuleID) REFERENCES YARARULES(ID) ON DELETE CASCADE ON UPDATE CASCADE, FOREIGN KEY (SampleID) REFERENCES SAMPLES(ID) ON DELETE CASCADE ON UPDATE CASCADE)";
        Connection conn = db.getConnection(this);
        try {
            Statement statement = conn.createStatement();
            statement.executeUpdate(createRulesTable);
            statement.executeUpdate(createMatchTable);
            this.moduleID = db.registerModule(conn, RulesAnalysisModule.engineName);
        } catch (SQLException e) {
            e.printStackTrace();
        }
        db.releaseConnection(conn);

        ScannerEngineUtils.RuleImportTask ruleImportTask = new ScannerEngineUtils.RuleImportTask(new File[]{new File("config/rules/index.yar")}, this, yara, compiler);
        ruleImportTask.run();

        conn = db.getConnection(this);
        trainedRules = getRuleNames(conn);
        db.releaseConnection(conn);
        File treeFile = new File("./config/yaraRuleTree");
        try {
            decisionTree = new Gson().fromJson(new FileReader(treeFile), TreeNode.class);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            //TODO handle missing decision tree.
            //TODO Add ability for server to report errors to client w/r processing reports.
        }

        isSetup = true;
    }

    private void setup() {
        this.setup(AntiVirusServer.getInstance().getDatabaseEngine());
    }


    @Override
    public TrainTask train(Utils.FileStatus fileStatus, File[] files) {
        RuleTrainTask trainTask = new RuleTrainTask("Yara Rule Training", files, fileStatus);
        return trainTask;
    }

    @Override
    public AnalysisTask processReport(ScanReport scanReport) {
        AnalysisTask analysisTask = new RuleAnalysisTask("Yara Rule Analysis", scanReport);
        return analysisTask;
    }

    private class RuleAnalysisTask extends AnalysisTask {

        protected RuleAnalysisTask(String taskName, ScanReport report) {
            super(taskName, report);
        }

        @Override
        public void processFile(FileFeatures fileFeatures) throws SQLException {
            HashMap<String, String> features = new HashMap<>();
            HashSet<String> rules = new HashSet<>();
            for (String rule : trainedRules) {
                if(fileFeatures.featureList.contains(rule)){
                    rules.add(rule);
                }
            }

            fileFeatures.featureMap.forEach((feature, value) -> {
                features.put(feature.toString(), value);
            });

            DataElement element = new DataElement(null, features, rules);
            if(decisionTree.classify(element).equalsIgnoreCase("MALWARE")) {
                resultsReport.addMalware(new MalwareEntry(fileFeatures.filePath, -0, ""));
            }
        }

        @Override
        public void run() {
            if(!RulesAnalysisModule.this.isSetup){
                setup();
            }
            super.run();
        }
    }


    private class RuleTrainTask extends TrainTask {
        Utils.FileStatus fileStatus;
        YaraScanner scanner;

        protected RuleTrainTask(String taskName, File[] files, Utils.FileStatus fileStatus) {
            super(taskName, files, RulesAnalysisModule.this);
            this.fileStatus = fileStatus;
        }

        @Override
        protected void processFile(File file){
            Connection connection = db.getConnection(this);
            try {
//                if(canTrain(file)) {
                    connection.setAutoCommit(false);
                    int sampleID = db.addSampleIfNotExists(connection, file, fileStatus == Utils.FileStatus.MALWARE);
                    if (db.isModuleTrained(connection, moduleID, sampleID)) {
                        //We've already trained the module on this sample.
                        this.report.incrementExisting();
                        db.releaseConnection(connection);
                        return;
                    }
                    scanner.scan(file, null, yaraRule -> {
                        try {
                            int ruleID = getRuleID(connection, yaraRule);
                            addRuleMatch(connection, sampleID, ruleID);
                        } catch (SQLException e) {
                        }
                    });
                    this.report.incrementTrained();
                    db.markSampleTrained(connection, moduleID, sampleID);
                    connection.commit();
//                }
            }catch (YaraException | SQLException | IOException e){
                this.report.incrementFailed();
            }finally {
                try{
                    connection.setAutoCommit(true);
                }catch (SQLException ignored){}
            }
            db.releaseConnection(connection);
        }

        private boolean canTrain(File file){
            return true;
//            String[] suitable = new String[]{"application/x-ms-dos-executable", "application/x-msdownload"};
//            try {
//                String mime = Files.probeContentType(file.toPath());
//                for (String valid : suitable) {
//                    if(mime.equalsIgnoreCase(valid)) return true;
//                }
//                return false;
//            } catch (IOException e) {
//                return false;
//            }
        }

        @Override
        public void run() {
            if(!RulesAnalysisModule.this.isSetup){
                setup();
            }
            scanner = compiler.createScanner();
            super.run();
            try {
                createTree();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }


    /**
     * Finds the id for a yara rule or inserts into the table and returns the generated row id.
     * @param rule The rule to be searched for
     * @return int the identifier for the rule.
     */
    private int getRuleID(Connection connection, YaraRule rule) throws SQLException{
        PreparedStatement stmt = connection.prepareStatement("SELECT id from YARARULES WHERE RULENAME=? LIMIT 1");
        stmt.setString(1, rule.getIdentifier());
        ResultSet results = stmt.executeQuery();
        if(results.next()){
            return results.getInt(1);
        }else{
            stmt = connection.prepareStatement("INSERT INTO YARARULES VALUES (NULL, ?)", PreparedStatement.RETURN_GENERATED_KEYS);
            stmt.setString(1, rule.getIdentifier());
            stmt.executeUpdate();
            results = stmt.getGeneratedKeys();
            if(results.next()){
                return results.getInt(1);
            }
        }
        return -1;
    }

    private boolean addRuleMatch(Connection connection, int sampleID, int ruleID) throws SQLException{
        PreparedStatement stmt = connection.prepareStatement("INSERT INTO YARAMATCHES VALUES(?,?)");
        stmt.setInt(1, ruleID);
        stmt.setInt(2, sampleID);
        int effectedRows = stmt.executeUpdate();
        return effectedRows != 0;
    }

    private ArrayList<String> getRuleNames(Connection connection){
        Statement stmt = null;
        try {
            stmt = connection.createStatement();
            ResultSet rs = stmt.executeQuery("SELECT RuleName From YaraRules");
            ArrayList<String> rules = new ArrayList<>();
            while (rs.next()) {
                String rulename = rs.getString(1);
                Feature f = new Feature(rulename, Arrays.asList(new String[]{"true", "false"}));
                rules.add(f.name);
            }
            return rules;
        } catch (SQLException e) {
            return null;
        }
    }

    private void createTree() throws SQLException {
        C45 c45 = new C45("CLEAN", "MALWARE", 5);
        HashMap<Integer, DataElement> dataElements = new HashMap<>();
        HashMap<String, Feature> features = new HashMap<>();

        String selectRuleNames = "SELECT RuleName From YaraRules";
        //TODO Fix sample select. Only select trained samples
        String selectSamples = "(SELECT ID, MALWARE, MIMETYPES.MIME FROM SAMPLES LEFT JOIN MIMETYPES ON SAMPLES.MIME = MIMETYPES.ID)";
        String selectRuleMatches = "(SELECT SAMPLEID,RULENAME FROM SAMPLES INNER JOIN YARAMATCHES ON SAMPLES.ID = YARAMATCHES.SAMPLEID INNER JOIN YARARULES ON YARAMATCHES.RULEID = YARARULES.ID ORDER BY SAMPLEID)";

        Connection connection = db.getConnection(this);
        Statement stmt = connection.createStatement();
        ResultSet rs = stmt.executeQuery(selectRuleNames);
        while (rs.next()) {
            String rulename = rs.getString(1);
            Feature f = new Feature(rulename, Arrays.asList(new String[]{"true", "false"}));
            features.put(f.name, f);
        }

        //ADD Mime Type as Feature
        features.put(FileFeatures.Feature.MIME_TYPE.toString(),
                new Feature(FileFeatures.Feature.MIME_TYPE.toString(), db.getMimeTypes(connection)));


        rs = stmt.executeQuery(selectSamples);
        while (rs.next()) {
            int id = rs.getInt(1);
            String classification = rs.getBoolean(2) ? "MALWARE" : "CLEAN";
            HashMap<String, String> elementFeatures = new HashMap<>();
            for (Feature feature : features.values()) {
                elementFeatures.put(feature.name, "false");
            }
            DataElement elem = new DataElement(classification, elementFeatures, null);
            dataElements.put(id, elem);
        }

        rs = stmt.executeQuery(selectRuleMatches);
        while (rs.next()) {
            int sampleID = rs.getInt(1);
            String ruleName = rs.getString(2);
            dataElements.get(sampleID).labels.add(ruleName);
            String mime = rs.getString(3);
            dataElements.get(sampleID).features.put(FileFeatures.Feature.MIME_TYPE.toString(), mime);
        }

        db.releaseConnection(connection);

        c45.addFeatures(new ArrayList<>(features.values()));
        c45.addTrainingElements(new ArrayList<>(dataElements.values()));
        c45.createTree();

        Gson gson = new Gson();
        String tree = gson.toJson(c45.root);
        File ruleTree = new File("./config/yaraRuleTree");
        PrintWriter writer = null;
        try {
            writer = new PrintWriter(new FileWriter(ruleTree));
            writer.println(tree);
            writer.flush();
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public JPanel getStatPanel() {
        if(!isSetup) {
            setup(AntiVirusServer.getInstance().getDatabaseEngine());
        }

        Connection connection = db.getConnection(this);
        HashMap<Boolean, Integer> trainedCount = (HashMap<Boolean, Integer>) db.getModuleTrainedCount(connection, this.moduleID);
        db.releaseConnection(connection);

        JPanel panel = new JPanel(new GridBagLayout());
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.weightx = gbc.weighty = 1.0;
        gbc.gridx = gbc.gridy = 1;
        gbc.fill = GridBagConstraints.BOTH;
        TitledBorder border = BorderFactory.createTitledBorder("Yara Rule Analytics");
//        border.setTitleJustification(TitledBorder.CENTER);
        border.setTitleColor(Color.BLUE);
        panel.setBorder(border);
        panel.add(new JLabel(String.format("Clean Samples Trained: %d", trainedCount.get(false))), gbc);
        gbc.gridy++;
        panel.add(new JLabel(String.format("Malicious Samples Trained: %d", trainedCount.get(true))), gbc);
        gbc.gridy=1;
        gbc.gridx++;
        panel.add(new JLabel(String.format("Unique Rules Matched: %d", this.trainedRules.size())), gbc);

        gbc.gridx = 1;
        gbc.gridwidth = 2;
        gbc.gridy = 10;
        panel.add(new JLabel("Ready to Classify: " + (this.decisionTree == null ? "FALSE" : "TRUE")), gbc);
        return panel;
    }
}
