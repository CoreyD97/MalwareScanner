package com.coreyd97.antivirus.common.taskscheduler;

import com.coreyd97.antivirus.common.engine.DetectionModule;
import com.coreyd97.antivirus.common.report.ReportHandler;
import com.coreyd97.antivirus.common.report.ReportPublisher;
import com.coreyd97.antivirus.common.report.TrainReport;
import com.coreyd97.antivirus.common.utils.Utils;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.util.concurrent.ExecutorService;

public abstract class TrainTask extends Task<TrainReport> implements ReportPublisher, ThreadedTask {
    enum ReportFrequency {SINGLE, BATCH, INDIVIDUAL}
    private File[] files;
    private final DetectionModule module;
    protected TrainReport report;
    protected ReportFrequency reportFrequency;
    private ReportHandler reportHandler;
    private int pendingReportCount = 0;
    private int reportSize = 100;

    private ExecutorService executor;
    private int pendingThreadCount = 0;

    protected TrainTask(String taskName, File[] files, DetectionModule detectionModule) {
        super(taskName);
        this.files = files;
        this.module = detectionModule;
        this.report = new TrainReport(detectionModule, this);
        this.reportFrequency = ReportFrequency.BATCH;
    }

    public void setExecutorService(ExecutorService executorService) {
        this.executor = executorService;
    }

    public void setReportFrequency(ReportFrequency reportFrequency) {
        this.reportFrequency = reportFrequency;
    }

    public void setReportHandler(ReportHandler reportHandler){
        this.reportHandler = reportHandler;
    }

    //Implement in subclasses to define handling of each file.
    protected abstract void processFile(File file);

    private void processFiles(File files[]){
        for (File file : files) {
            if(file.isDirectory()){
                try {
                    if (FileUtils.isSymlink(file)){
                        continue;
                    }
                }catch (IOException ignored){}

                File[] childFiles = file.listFiles();
                if(childFiles == null) continue;
                processFiles(childFiles);
            }else if(file.isFile()){
                if(this.executor != null){
                    //If we're multithreading
                    this.executor.submit(() -> {
                        processFile(file);
                        publishReport();
                        taskProgress();
                        pendingThreadCount--;
                    });
                    pendingThreadCount++;
                }else {
                    processFile(file);
                    publishReport();
                    taskProgress();
                }
            }else{
                //Linux device file or similar.
                taskProgress();
            }
        }
    }

    private void publishReport(){
        synchronized (this.report){
            if(this.reportHandler == null) return;
            switch (reportFrequency) {
                case INDIVIDUAL: {
                    this.reportHandler.onReportReady(report);
                    this.report = new TrainReport(this.module, this);
                    break;
                }
                case BATCH: {
                    if(this.pendingReportCount++ == this.reportSize){
                        this.reportHandler.onReportReady(report);
                        this.report = new TrainReport(this.module, this);
                        this.logMessage(TaskLogListener.MessageType.LOG, "Batch report of " + this.pendingReportCount + " files submitted for analysis.");
                        this.pendingReportCount = 0;
                    }
                    break;
                }
            }
        }
    }

    public void run() {
        taskStart(Utils.countFiles(files));
        processFiles(this.files);

        while(this.pendingThreadCount != 0){ //Wait for all threads to complete
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {}
        }
        if(this.reportHandler != null) {
            if (this.reportFrequency == ReportFrequency.SINGLE) {
                this.reportHandler.onReportReady(report);
            } else if (this.reportFrequency == ReportFrequency.BATCH && this.pendingReportCount != 0) {
                this.logMessage(TaskLogListener.MessageType.LOG, "Batch report of " + this.pendingReportCount + " files submitted for analysis.");
            }
        }
        this.completed = true;
        if(this.callback != null)
            new Thread(this.callback).start();
        logMessage(TaskLogListener.MessageType.INFO, "Train Task Complete");
        taskComplete();
    }

    public TrainReport getReport() {
        return report;
    }
}
