package com.coreyd97.antivirus.common.taskscheduler;

import com.coreyd97.antivirus.common.utils.Utils;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * The base for all tasks which iterate over a set of files and their children.
 * @param <T> The return type.
 */
public abstract class FileSystemTask<T> extends Task<T> implements ThreadedTask {
    protected final ArrayList<IFileTaskListener> taskFileListeners;
    private ExecutorService executor;
    protected AtomicInteger pendingThreadCount;

    private final File[] files;

    protected FileSystemTask(String taskName, File[] files) {
        super(taskName);
        this.files = files;
        this.pendingThreadCount = new AtomicInteger();
        this.taskFileListeners = new ArrayList<>();
    }

    public void setExecutorService(ExecutorService executorService) {
        this.executor = executorService;
    }

    /**
     * Process a single file
     * @param file The file to be processed.
     * @return Boolean value, true if processed, false if skipped.
     */
    protected abstract boolean processFile(File file);

    //Navigate through the array of files and process all child files along the way.
    protected void processFiles(File files[]){
        for (File file : files) {
            if(file.isDirectory()){
                try {
                    if (FileUtils.isSymlink(file)){
                        continue;
                    }
                }catch (IOException ignored){}

                //Get child files and process each one.
                File[] childFiles = file.listFiles();
                if(childFiles == null) continue;
                synchronized (this.taskFileListeners){
                    this.taskFileListeners.forEach(listener -> listener.onDirectoryEntered(file));
                }
                processFiles(childFiles);
                synchronized (this.taskFileListeners){
                    this.taskFileListeners.forEach(listener -> listener.onDirectoryLeft(file));
                }
            }else if(file.isFile()){
                //Handle the file and update any listeners along the way at each stage.
                Runnable fileTask = () -> {
                    try {
                        FileSystemTask.this.taskFileListeners.forEach(listener -> listener.onFileStart(file));
                    } catch (Exception ignored) {}
                    try{
                        boolean fileProcessed = FileSystemTask.this.processFile(file);
                        if (fileProcessed) {
                            try {
                                FileSystemTask.this.taskFileListeners.forEach(listener -> listener.onFileComplete(file));
                            } catch (Exception ignored) {}
                        } else {
                            try{
                                FileSystemTask.this.taskFileListeners.forEach(listener -> listener.onFileSkipped(file));
                            } catch (Exception ignored) {}
                        }
                    }catch (Exception e){
                        try{
                            FileSystemTask.this.taskFileListeners.forEach(listener -> listener.onFileFailed(file, e));
                        } catch (Exception ignored) {}
                    }
                    FileSystemTask.this.taskProgress();
                    pendingThreadCount.getAndDecrement();
                };

                //Fill scanReport with file features
                if(this.executor != null){
                    //If we're multithreading add to executor
                    this.pendingThreadCount.getAndIncrement();
                    this.executor.execute(fileTask);

                }else {
                    //Otherwise run directly
                    fileTask.run();
                }
            }else{
                //Linux device file or similar, ignore it!
                taskProgress();
            }
        }
    }

    @Override
    public int getChildPriority() {
        return 0;
    }

    /**
     * Called when all files have been processed.
     */
    protected abstract void allThreadsComplete();


    @Override
    public void run() {
        taskStart(Utils.countFiles(files));
        logMessage(TaskLogListener.MessageType.INFO, "Task Started - " + this.taskName);
        processFiles(this.files);

        while(pendingThreadCount.get() > 0){ //While we're waiting for files to be processed, sleep.
            try{
                Thread.sleep(1000);
            }catch (InterruptedException ignored){}
        }


        //Run anything subclasses require after all
        //threads have been completed. E.g. collate results (scantask)
        allThreadsComplete();

        this.completed = true;
        if(this.callback != null){
            new Thread(this.callback).start();
        }
        logMessage(TaskLogListener.MessageType.INFO, "Task Complete - " + this.taskName);
        taskComplete();
    }

    public void registerFileListener(IFileTaskListener listener){
        synchronized (this.taskFileListeners){
            this.taskFileListeners.add(listener);
        }
    }

    public void removeFileListener(IFileTaskListener listener){
        synchronized (this.taskFileListeners){
            this.taskFileListeners.remove(listener);
        }
    }

    public File[] getStartFiles() {
        return files;
    }
}
