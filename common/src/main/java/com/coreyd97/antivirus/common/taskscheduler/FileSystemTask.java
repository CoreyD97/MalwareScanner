package com.coreyd97.antivirus.common.taskscheduler;

import com.coreyd97.antivirus.common.utils.Utils;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicInteger;

public abstract class FileSystemTask<T> extends Task<T> implements ThreadedTask {
    protected final ArrayList<IFileTaskListener> taskFileListeners;
    private ExecutorService executor;
    protected AtomicInteger pendingThreadCount;

    private final File[] files;

    protected FileSystemTask(String taskName, File[] files) {
        super(taskName);
        this.files = files;
        this.pendingThreadCount = new AtomicInteger();
        this.taskFileListeners = new ArrayList<>();
    }

    public void setExecutorService(ExecutorService executorService) {
        this.executor = executorService;
    }

    //Implement in subclasses to define handling of each file.
    protected abstract boolean processFile(File file);

    protected void processFiles(File files[]){
        for (File file : files) {
            if(file.isDirectory()){
                try {
                    if (FileUtils.isSymlink(file)){
                        continue;
                    }
                }catch (IOException ignored){}

                File[] childFiles = file.listFiles();
                if(childFiles == null) continue;
                synchronized (this.taskFileListeners){
                    this.taskFileListeners.forEach(listener -> listener.onDirectoryEntered(file));
                }
                processFiles(childFiles);
                synchronized (this.taskFileListeners){
                    this.taskFileListeners.forEach(listener -> listener.onDirectoryLeft(file));
                }
            }else if(file.isFile()){
                Runnable fileTask = () -> {
                    try {
                        FileSystemTask.this.taskFileListeners.forEach(listener -> listener.onFileStart(file));
                    } catch (Exception ignored) {}
                    try{
                        boolean fileProcessed = FileSystemTask.this.processFile(file);
                        if (fileProcessed) {
                            try {
                                FileSystemTask.this.taskFileListeners.forEach(listener -> listener.onFileComplete(file));
                            } catch (Exception ignored) {}
                        } else {
                            try{
                                FileSystemTask.this.taskFileListeners.forEach(listener -> listener.onFileSkipped(file));
                            } catch (Exception ignored) {}
                        }
                    }catch (Exception e){
                        try{
                            FileSystemTask.this.taskFileListeners.forEach(listener -> listener.onFileFailed(file, e));
                        } catch (Exception ignored) {}
                    }
                    FileSystemTask.this.taskProgress();
                    pendingThreadCount.getAndDecrement();
                };

                //Fill scanReport with file features
                if(this.executor != null){
                    //If we're multithreading add to executor
                    this.pendingThreadCount.getAndIncrement();
                    this.executor.execute(fileTask);

                }else {
                    //Otherwise run
                    fileTask.run();
                }
            }else{
                //Linux device file or similar.
                taskProgress();
            }
        }
    }

    @Override
    public int getChildPriority() {
        return 0; //TODO Use ME
    }

    protected abstract void allThreadsComplete();

    @Override
    public void run() {
        taskStart(Utils.countFiles(files));
        logMessage(TaskLogListener.MessageType.INFO, "Task Started - " + this.taskName);
        processFiles(this.files);

        while(pendingThreadCount.get() > 0){
            try{
                Thread.sleep(1000);
            }catch (InterruptedException ignored){}
        }


        //Run anything subclasses require after all
        //threads have been completed. E.g. collate results (scantask)
        allThreadsComplete();

        this.completed = true;
        if(this.callback != null){
            new Thread(this.callback).start();
        }
        logMessage(TaskLogListener.MessageType.INFO, "Task Complete - " + this.taskName);
        taskComplete();
    }

    public void registerFileListener(IFileTaskListener listener){
        synchronized (this.taskFileListeners){
            this.taskFileListeners.add(listener);
        }
    }

    public void removeFileListener(IFileTaskListener listener){
        synchronized (this.taskFileListeners){
            this.taskFileListeners.remove(listener);
        }
    }

    public File[] getStartFiles() {
        return files;
    }
}
