package com.coreyd97.antivirus.common.taskscheduler;

import com.coreyd97.antivirus.common.utils.Utils;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.concurrent.ExecutorService;

public abstract class FileSystemTask<T> extends Task<T> implements ThreadedTask {
    protected final ArrayList<IFileTaskListener> taskFileListeners;
    private ExecutorService executor;
    protected Integer pendingThreadCount;

    private final File[] files;

    protected FileSystemTask(String taskName, File[] files) {
        super(taskName);
        this.files = files;
        this.pendingThreadCount = 0;
        this.taskFileListeners = new ArrayList<>();
    }

    public void setExecutorService(ExecutorService executorService) {
        this.executor = executorService;
    }

    //Implement in subclasses to define handling of each file.
    protected abstract boolean processFile(File file);

    protected void processFiles(File files[]){
        for (File file : files) {
            if(file.isDirectory()){
                try {
                    if (FileUtils.isSymlink(file)){
                        continue;
                    }
                }catch (IOException ignored){}

                File[] childFiles = file.listFiles();
                if(childFiles == null) continue;
                synchronized (this.taskFileListeners){
                    this.taskFileListeners.forEach(listener -> listener.onDirectoryEntered(file));
                }
                processFiles(childFiles);
                synchronized (this.taskFileListeners){
                    this.taskFileListeners.forEach(listener -> listener.onDirectoryLeft(file));
                }
            }else if(file.isFile()){
                //TODO add multithreading like TrainTask
                //Fill scanReport with file features
                if(this.executor != null){
                    //If we're multithreading
                    this.executor.execute(() -> {
                        synchronized (this.taskFileListeners){
                            try {
                                this.taskFileListeners.forEach(listener -> listener.onFileStart(file));
                            }catch (Exception e){
                                e.printStackTrace();
                            }
                        }
                        boolean fileProcessed = processFile(file);
                        if(fileProcessed) {
                            synchronized (this.taskFileListeners) {
                                try {
                                    this.taskFileListeners.forEach(listener -> listener.onFileComplete(file));
                                } catch (Exception e) {
                                    e.printStackTrace();
                                }
                            }
                        }else{
                            synchronized (this.taskFileListeners){
                                this.taskFileListeners.forEach(listener -> listener.onFileSkipped(file));
                            }
                        }
                        taskProgress();
                        synchronized (pendingThreadCount) {
                            pendingThreadCount--;
                        }
                    });
                    synchronized (pendingThreadCount) {
                        pendingThreadCount++;
                    }
                }else {
                    synchronized (this.taskFileListeners){
                        this.taskFileListeners.forEach(listener -> listener.onFileStart(file));
                    }
                    boolean fileProcessed = processFile(file);
                    if(fileProcessed){
                        synchronized (this.taskFileListeners){
                            this.taskFileListeners.forEach(listener -> listener.onFileComplete(file));
                        }
                    }else{
                        synchronized (this.taskFileListeners){
                            this.taskFileListeners.forEach(listener -> listener.onFileSkipped(file));
                        }
                    }
                    taskProgress();
                }
            }else{
                //Linux device file or similar.
                taskProgress();
            }
        }
    }

    protected abstract void allThreadsComplete();

    @Override
    public void run() {
        taskStart(Utils.countFiles(files));
        logMessage(TaskLogListener.MessageType.INFO, "Task Started - " + this.taskName);
        processFiles(this.files);

        while(this.pendingThreadCount != 0){
            try{
                Thread.sleep(1000);
            }catch (InterruptedException ignored){}
        }


        //Run anything subclasses require after all
        //threads have been completed. E.g. collate results (scantask)
        allThreadsComplete();

        this.completed = true;
        if(this.callback != null){
            new Thread(this.callback).start();
        }
        logMessage(TaskLogListener.MessageType.INFO, "Task Complete - " + this.taskName);
        taskComplete();
    }

    public void registerFileListener(IFileTaskListener listener){
        synchronized (this.taskFileListeners){
            this.taskFileListeners.add(listener);
        }
    }

    public void removeFileListener(IFileTaskListener listener){
        synchronized (this.taskFileListeners){
            this.taskFileListeners.remove(listener);
        }
    }

    public File[] getStartFiles() {
        return files;
    }
}
