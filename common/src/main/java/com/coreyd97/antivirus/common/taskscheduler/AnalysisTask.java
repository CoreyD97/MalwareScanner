package com.coreyd97.antivirus.common.taskscheduler;

import com.coreyd97.antivirus.common.report.*;

import java.sql.SQLException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Logger;

/**
 * The main engine to all Analysis Tasks.
 * Takes a scan report and iterates through all (file, features) sets.
 * When malware is found, an entry is added to the results report.
 */
public abstract class AnalysisTask extends Task<ResultsReport> implements ReportPublisher<ResultsReport>, ThreadedTask {
    protected ScanReport scanReport;
    protected ResultsReport resultsReport;
    private ReportHandler<ResultsReport> reportHandler;
    private ExecutorService executorService;
    private AtomicInteger pendingTasks;

    protected AnalysisTask(String taskName, ScanReport scanReport) {
        super(taskName);
        this.scanReport = scanReport;
        this.resultsReport = new ResultsReport(scanReport);
        this.pendingTasks = new AtomicInteger();
    }

    public void setReportHandler(ReportHandler<ResultsReport> reportHandler){
        this.reportHandler = reportHandler;
    }

    @Override
    public void setExecutorService(ExecutorService executorService) {
        this.executorService = executorService;
    }

    //Implement in subclasses to define handling of each file.
    protected abstract void processFile(FileFeatures features) throws SQLException;

    private void processReport(){
        if(this.reportHandler != null) {
            this.reportHandler.onReportReady(resultsReport);
        }
    }

    public void run() {
        if(scanReport.getFileFeatures() != null) {
            taskStart(scanReport.getFileFeatures().size());
            scanReport.getFileFeatures().forEach(fileFeatures -> { //For each set of features
                Runnable r = new Runnable() {
                    @Override
                    public void run() {
                        try {
                            processFile(fileFeatures); //Process the features as defined in the subclass.
                        } catch (SQLException e) {
                            Logger.getLogger("Analysis").warning("SQL EXCEPTION - " + e.getSQLState());
                        }catch (Exception e){
                            Logger.getLogger("Analysis").warning(e.getMessage());
                        }
                        pendingTasks.getAndDecrement();
                        taskProgress();
                    }
                };

                if(this.executorService == null){
                    r.run();
                }else{
                    //Increment the number of pending tasks.
                    this.pendingTasks.getAndIncrement();
                    //Submit the analysis child task to be processed.
                    this.executorService.execute(r);
                }

            });
        }

        //While we're still waiting for some file feature sets to be analysed, wait here.
        while(this.pendingTasks.get() != 0){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ignored) {}
        }

        taskComplete();
        processReport();
        this.completed = true;
        if(this.callback != null)
            this.callback.run();
    }

    @Override
    public int getPriority() {
        return 10; //Most important task!
    }

    @Override
    public int getChildPriority() {
        return 0;
    }
}
