package com.coreyd97.antivirus.common.taskscheduler;

import com.coreyd97.antivirus.common.stats.StatProvider;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.concurrent.*;
import java.util.logging.Logger;

public class TaskScheduler extends ThreadPoolExecutor implements StatProvider {
    ArrayList<Task> tasks;
    ArrayList<TaskSchedulerListener> schedulerListeners;

    public TaskScheduler(int threads){
        super(threads, threads, 5000, TimeUnit.MILLISECONDS, new PriorityBlockingQueue<>(100, new PriorityTaskComparator()), new TaskSchedulerThreadFactory());
        this.tasks = new ArrayList<>();
        this.schedulerListeners = new ArrayList<>();
    }

    public TaskScheduler(){
        this(10);
    }

    @Override
    public void execute(Runnable task) {
        if(task instanceof Task){
            if(task instanceof ThreadedTask){
                ((ThreadedTask) task).setExecutorService(this);
            }
            this.tasks.add((Task) task);
            for (TaskSchedulerListener schedulerListener : schedulerListeners) {
                schedulerListener.onTaskAdded((Task) task);
            }
            Logger.getLogger("TaskScheduler").info("Task \"" + ((Task) task).getTaskName() + "\" Submitted and Registered with " + schedulerListeners.size() + " listeners.");
        }
        super.execute(task);
    }

    @Override
    protected void afterExecute(Runnable runnable, Throwable throwable) {
        super.afterExecute(runnable, throwable);
        if(runnable instanceof Task) {
            for (TaskSchedulerListener schedulerListener : this.schedulerListeners) {
                schedulerListener.onTaskRemoved((Task) runnable);
            }
            this.tasks.remove(runnable);
            Logger.getLogger("TaskScheduler").info("Task \"" + ((Task) runnable).getTaskName() + "\" Removed");

            if (throwable != null){
                synchronized (this.schedulerListeners){
                    for (TaskSchedulerListener schedulerListener : this.schedulerListeners) {
                        schedulerListener.onTaskException((Task) runnable, throwable);
                    }
                }
                ((Task) runnable).onError(throwable);
            }
        }
    }

    public static class PriorityTaskComparator implements Comparator<Runnable> {
        @Override
        public int compare(final Runnable a, final Runnable b) {
            int pA = 0, pB = 0;
            if(a instanceof Task) pA = ((Task) a).getPriority();
            if(b instanceof Task) pB = ((Task) b).getPriority();

            final long diff = pB - pA;
            return 0 == diff ? 0 : 0 > diff ? -1 : 1;
        }
    }

    public void registerSchedulerListener(TaskSchedulerListener listener){
        this.schedulerListeners.add(listener);
    }

    public void removeSchedulerListener(TaskSchedulerListener listener){
        this.schedulerListeners.remove(listener);
    }

    private JPanel statPanel;
    private JLabel activeTasks;
    private JLabel totalThreadsLabel;
    private JLabel activeThreads;
    private JLabel availableThreadsLabel;
    private JLabel queueSizeLabel;

    @Override
    public JPanel getStatPanel() {
        if(statPanel == null) {
            statPanel = new JPanel(new GridLayout(0, 2));

            TitledBorder border = BorderFactory.createTitledBorder("Task Scheduler");
            border.setTitleColor(Color.BLUE);
            statPanel.setBorder(border);
            activeTasks = new JLabel();
            totalThreadsLabel = new JLabel();
            activeThreads = new JLabel();
            availableThreadsLabel = new JLabel();
            queueSizeLabel = new JLabel();

            statPanel.add(totalThreadsLabel);
            statPanel.add(activeThreads);
            statPanel.add(availableThreadsLabel);
            statPanel.add(activeTasks);
            statPanel.add(queueSizeLabel);
        }

        totalThreadsLabel.setText("Total Threads: " + this.getCorePoolSize());
        activeThreads.setText("Threads in-use: " + this.getActiveCount());
        availableThreadsLabel.setText("Threads available: " + (this.getCorePoolSize() - this.getActiveCount()));

        activeTasks.setText("Active Tasks: " + this.tasks.size());
        queueSizeLabel.setText("Queue Size: " + this.getQueue().size());
        statPanel.revalidate();
        statPanel.repaint();
        return statPanel;
    }
}
