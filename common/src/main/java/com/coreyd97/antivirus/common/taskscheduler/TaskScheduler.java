package com.coreyd97.antivirus.common.taskscheduler;

import com.coreyd97.antivirus.common.stats.StatProvider;

import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.concurrent.*;
import java.util.logging.Logger;

public class TaskScheduler extends ThreadPoolExecutor implements StatProvider {
    ArrayList<Task> tasks;
    ArrayList<TaskSchedulerListener> schedulerListeners;

    public TaskScheduler(int threads){
        super(threads, threads, 5000, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(), new TaskSchedulerThreadFactory());
        this.tasks = new ArrayList<>();
        this.schedulerListeners = new ArrayList<>();
    }

    public TaskScheduler(){
        this(10);
    }


    public void submit(Task task) {
        if(task instanceof ThreadedTask){
            ((ThreadedTask) task).setExecutorService(this);
        }
        this.tasks.add(task);
        for (TaskSchedulerListener schedulerListener : schedulerListeners) {
            schedulerListener.onTaskAdded(task);
        }
        Logger.getLogger("TaskScheduler").info("Task \"" + task.getName() + "\" Submitted and Registered with " + schedulerListeners.size() + " listeners.");
        super.execute(task);
    }


    @Override
    protected void afterExecute(Runnable runnable, Throwable throwable) {
        super.afterExecute(runnable, throwable);
        if(runnable instanceof Task) {
            for (TaskSchedulerListener schedulerListener : this.schedulerListeners) {
                schedulerListener.onTaskRemoved((Task) runnable);
            }
            this.tasks.remove(runnable);
            Logger.getLogger("TaskScheduler").info("Task \"" + ((Task) runnable).getName() + "\" Removed");

            if (throwable != null){
                synchronized (this.schedulerListeners){
                    for (TaskSchedulerListener schedulerListener : this.schedulerListeners) {
                        schedulerListener.onTaskException((Task) runnable, throwable);
                    }
                }
                ((Task) runnable).onError(throwable);
            }
        }
    }


    public void registerSchedulerListener(TaskSchedulerListener listener){
        this.schedulerListeners.add(listener);
    }

    public void removeSchedulerListener(TaskSchedulerListener listener){
        this.schedulerListeners.remove(listener);
    }

    private JPanel statPanel;
    private JLabel activeTasks;
    private JLabel threadCount;
    private JLabel activeThreads;
    private JLabel completedTasks;

    @Override
    public JPanel getStatPanel() {
        if(statPanel == null) {
            statPanel = new JPanel(new GridBagLayout());
            GridBagConstraints gbc = new GridBagConstraints();
            gbc.weightx = gbc.weighty = 1.0;
            gbc.fill = GridBagConstraints.BOTH;
            TitledBorder border = BorderFactory.createTitledBorder("Task Scheduler");
            border.setTitleColor(Color.BLUE);
            statPanel.setBorder(border);
            activeTasks = new JLabel();
            statPanel.add(activeTasks, gbc);
            gbc.gridx++;
            threadCount = new JLabel();
            statPanel.add(threadCount, gbc);
            gbc.gridx++;
            activeThreads = new JLabel();
            statPanel.add(activeThreads, gbc);
            gbc.gridx++;
            completedTasks = new JLabel();
            statPanel.add(completedTasks, gbc);
            gbc.gridx++;
        }

        activeTasks.setText("Active Tasks: " + this.tasks.size());
        threadCount.setText("Available Threads: " + this.getCorePoolSize());
        activeThreads.setText("Threads in-use: " + this.getActiveCount());
        completedTasks.setText("Completed Thread Tasks: " + this.getCompletedTaskCount());
        statPanel.revalidate();
        statPanel.repaint();
        return statPanel;
    }
}
