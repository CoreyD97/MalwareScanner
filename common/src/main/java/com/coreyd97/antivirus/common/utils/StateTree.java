package com.coreyd97.antivirus.common.utils;

import com.coreyd97.antivirus.common.exception.TreePathException;

import java.io.File;
import java.util.Arrays;
import java.util.HashMap;

public abstract class StateTree {

    String nodeName;
    StateTree parent;
    HashMap<String, StateTree> children;

    protected StateTree(String nodeName, StateTree parent){
        this.parent = parent;
        this.nodeName = nodeName;
    }

    public StateTree(String nodeName){
        this(nodeName, null);
    }

    public StateTree getParent() {
        return parent;
    }

    public String getPath(){
        if(this.parent == null) return this.nodeName;
        return this.parent.getPath() + File.separator + this.nodeName;
    }

    public String[] toRelPath(String nodePath) throws TreePathException {
        String currentPath = this.getPath();
        if (!nodePath.startsWith(currentPath)) {
            throw new TreePathException("The directory entered is not part of this tree!");
        }
        if(nodePath.equals(currentPath)){
            return new String[]{};
        }
        String[] relPath = nodePath.substring(currentPath.length()).split(File.separator);
        return relPath;
    }


    public StateTree getDescendant(String[] relPath) throws TreePathException {
        if(relPath.length == 0) return this;
        if(this.children == null){
            throw new TreePathException("Cannot get descendants of a file. " + this.getPath());
        }else{
            StateTree child = this.children.get(relPath[0]);
            if(child == null){
                throw new TreePathException(this.getPath() + " does not have a child " + relPath[0]);
            }

            return child.getDescendant(Arrays.copyOfRange(relPath, 1, relPath.length));
        }
    }

    public StateTree getChild(String child){
        if(this.children != null){
            return this.children.get(child);
        }
        return null;
    }

    public StateTree getNearestDescendant(String[] relPath) {
        StateTree descendant = this;
        for (int i = 0; i < relPath.length; i++) {
            StateTree nextDescendant = descendant.getChild(relPath[i]);
            if(nextDescendant == null) return descendant;
            else descendant = nextDescendant;
        }
        return descendant;
    }

    protected StateTree addChild(String childName){
        if(this.children == null){
            this.children = new HashMap<>();
        }
        StateTree child = this.children.get(childName);
        if(child != null){
            return child;
        }else{
            child = createChild(childName);
        }

        this.children.put(childName, child);
        return child;
    }

    protected abstract StateTree createChild(String childName);
}

