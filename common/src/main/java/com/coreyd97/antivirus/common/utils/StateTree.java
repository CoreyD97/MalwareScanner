package com.coreyd97.antivirus.common.utils;

import com.coreyd97.antivirus.common.exception.TreePathException;

import java.io.File;
import java.util.Arrays;
import java.util.HashMap;

public abstract class StateTree {

    String nodeName;
    StateTree parent;
    HashMap<String, StateTree> children;
    boolean isLeaf;

    protected StateTree(String nodeName, StateTree parent, boolean isLeaf){
        this.parent = parent;
        this.nodeName = nodeName;

        this.isLeaf = isLeaf;
        if(!isLeaf){
            this.children = new HashMap<>();
        }
    }

    private StateTree(String nodeName){
        this(nodeName, null, false);
    }


    public StateTree getParent() {
        return parent;
    }

    public String getPath(){
        if(this.parent == null) return this.nodeName;
        return this.parent.getPath() + File.separator + this.nodeName;
    }

    public String[] toRelPath(String nodePath) throws TreePathException {
        String currentPath = this.getPath();
        if(!currentPath.substring(currentPath.length()-1).equals(File.separator)){
            currentPath += File.separator;
        }
        if (!nodePath.startsWith(currentPath)) {
            throw new TreePathException("The directory entered is not part of this tree!");
        }
        if(nodePath.equals(currentPath)){
            return new String[]{};
        }
        String[] relPath = nodePath.substring(currentPath.length()).split(File.separator);
        return relPath;
    }


    public StateTree getDescendant(String[] relPath) throws TreePathException {
        if(relPath.length == 0) return this;
        if(this.isLeafNode()){
            throw new TreePathException("Cannot get descendants of a file. " + this.getPath());
        }else{
            StateTree child = this.children.get(relPath[0]);
            if(child == null){
                throw new TreePathException(this.getPath() + " does not have a child " + relPath[0]);
            }

            return child.getDescendant(Arrays.copyOfRange(relPath, 1, relPath.length));
        }
    }

    public StateTree getChild(String child){
        if(!this.isLeafNode() && this.children != null){
            synchronized (this.children) {
                return this.children.get(child);
            }
        }
        return null;
    }

    public StateTree getNearestDescendant(String[] relPath) {
        StateTree descendant = this;
        for (int i = 0; i < relPath.length; i++) {
            StateTree nextDescendant = descendant.getChild(relPath[i]);
            if(nextDescendant == null) return descendant;
            else descendant = nextDescendant;
        }
        return descendant;
    }

    protected StateTree addChild(String childName, boolean isLeaf){
        if(this.isLeafNode()){
            synchronized (this.children) {
                this.children = new HashMap<>();
            }
        }
        StateTree child = this.children.get(childName);

        if(child != null){
            return null;
        }else{
            child = createChild(childName, isLeaf);
        }

        synchronized (this.children) {
            this.children.put(childName, child);
        }
        return child;
    }

    public boolean isLeafNode(){
        return this.isLeaf;
    }

    protected abstract StateTree createChild(String childName, boolean isLeaf);


    /**
     * @return Number of children generated.
     */
    protected abstract int populateChildren();
}

