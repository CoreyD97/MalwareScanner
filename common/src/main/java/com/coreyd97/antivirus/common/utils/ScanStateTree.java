package com.coreyd97.antivirus.common.utils;

import com.coreyd97.antivirus.common.exception.TreePathException;
import com.coreyd97.antivirus.common.taskscheduler.IFileTaskListener;
import com.coreyd97.antivirus.common.taskscheduler.IScanTaskListener;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.atomic.AtomicInteger;

public class ScanStateTree extends StateTree implements IFileTaskListener, IScanTaskListener {
    private enum ScanState{
        INCOMPLETE(0), SCANNING(1), PENDING_ANALYSIS(2), COMPLETED(3), SKIPPED(-1), FAILED(-2);
        public int priority;
        ScanState(int priority){
            this.priority = priority;
        }
    }

    ScanState state;
    boolean childrenPopulated;

    HashMap<ScanState, AtomicInteger> childStates;


    private ScanStateTree(String nodeName, ScanStateTree parent, boolean isLeaf){
        super(nodeName, parent, isLeaf);

        this.state = ScanState.INCOMPLETE;

        if (!this.isLeaf) {
            childStates = new HashMap<>();
            childStates.put(ScanState.INCOMPLETE, new AtomicInteger());
            childStates.put(ScanState.SCANNING, new AtomicInteger());
            childStates.put(ScanState.PENDING_ANALYSIS, new AtomicInteger());
            childStates.put(ScanState.COMPLETED, new AtomicInteger());
            childStates.put(ScanState.SKIPPED, new AtomicInteger());
            childStates.put(ScanState.FAILED, new AtomicInteger());
        }
    }

    public static ScanStateTree createTree(File file){
        String nodeName = file.getAbsolutePath();
        boolean isLeaf = !file.isDirectory();

        return new ScanStateTree(nodeName, null, isLeaf);
    }

    public ScanStateTree getParent() {
        return (ScanStateTree) parent;
    }

    public ScanStateTree getChild(String childName) {
        return (ScanStateTree) super.getChild(childName);
    }

    @Override
    protected int populateChildren() {
        File directory = new File(this.getPath());

        if(!directory.isDirectory()) return 0;

        synchronized (this) {
            if (this.isLeafNode()) {
                this.children = new HashMap<>();
            }

            int incompleteChildren = 0;

            File[] childFiles = directory.listFiles();
            if (childFiles != null) {
                for (File child : childFiles) {
                    try {
                        if (FileUtils.isSymlink(child)) continue;
                    } catch (IOException e) {
                    }
                    StateTree added = this.addChild(child.getName(), child.isFile());
                    File[] children;
                    if (added != null) {
                        incompleteChildren++;
                        if (child.isDirectory()) {
                            children = child.listFiles();
                            if (children != null && children.length == 0) {
                                ((ScanStateTree) added).setState(ScanState.COMPLETED);
                                incompleteChildren--;
                            }
                        }
                    }
                }
                incrementStateCount(ScanState.INCOMPLETE, incompleteChildren);
            }
            this.childrenPopulated = true;
            return incompleteChildren;
        }
    }

    public ScanState getState(String nodePath) throws TreePathException{
        return this.getState(this.toRelPath(nodePath));
    }

    private ScanState getState(String[] relPath) throws TreePathException {
        if(relPath.length == 0){
            return this.getState();
        }
        if(this.isLeafNode()){
            throw new TreePathException("Cannot get descendants of a file. " + this.getPath());
        }else{
            ScanStateTree child = this.getChild(relPath[0]);
            if(child == null){
                return this.getState();
            }

            return child.getState(Arrays.copyOfRange(relPath, 1, relPath.length));
        }
    }

    private void setState(ScanState state) {
        ScanState oldState;
        if (this.state == state) return;
        synchronized (this) {
            oldState = this.state;
            this.state = state;
        }

        //If we've completed entire directory remove children.
        if(this.state == ScanState.COMPLETED && !this.isLeaf){
            //Remove all completed children. They'll inherit this state.
            synchronized (this.children) {
                for (String key : new ArrayList<String>(this.children.keySet())) {
                    ScanStateTree child = (ScanStateTree) this.children.get(key);
                    if (child.getState() == ScanState.COMPLETED) {
                        this.children.remove(key);
                    }
                }
            }
        }
        //Update parent too if needed. (Bubble up)
        if(this.parent != null) {
            synchronized (this.parent) {
                ((ScanStateTree) this.parent).decrementStateCount(oldState, 1);
                ((ScanStateTree) this.parent).incrementStateCount(state, 1);
                ((ScanStateTree) this.parent).setState(((ScanStateTree) this.parent).getState());
            }
        }
    }

    protected ScanStateTree populateAndRetrieve(String[] relPath) throws TreePathException {
        if (!this.childrenPopulated) {
            this.populateChildren();
        }

        if(relPath.length == 0){
            return this;
        }else {
            if(this.isLeaf) throw new TreePathException(this.getPath() + " does not have a child: " + relPath[0] + " it's not a directory!");
            ScanStateTree child = (ScanStateTree) this.children.get(relPath[0]);
            if(child == null){
                throw new TreePathException(this.getPath() + " does not have a child: " + relPath[0]);
            }else{
                return child.populateAndRetrieve(Arrays.copyOfRange(relPath, 1, relPath.length));
            }
        }
    }

    protected void incrementStateCount(ScanState state, int count){
        AtomicInteger stateCount = this.childStates.get(state);
        for (int i = 0; i < count; i++) {
            stateCount.incrementAndGet();
        }
    }

    protected void decrementStateCount(ScanState state, int count){
        AtomicInteger stateCount = this.childStates.get(state);
        for (int i = 0; i < count; i++) {
            stateCount.decrementAndGet();
        }
    }

    @Override
    protected StateTree createChild(String childName, boolean isLeaf) {
        return new ScanStateTree(childName, this, isLeaf);
    }

    public ScanState getState(){
        if(this.isLeaf || this.state == ScanState.COMPLETED){
           return state;
        }else{
            int incomplete, scanning, pending, completed, skipped, failed;
            incomplete = this.childStates.get(ScanState.INCOMPLETE).get();
            scanning = this.childStates.get(ScanState.SCANNING).get();
            pending = this.childStates.get(ScanState.PENDING_ANALYSIS).get();
            completed = this.childStates.get(ScanState.COMPLETED).get();
            skipped = this.childStates.get(ScanState.SKIPPED).get();
            failed = this.childStates.get(ScanState.FAILED).get();
            ScanState state = ScanState.INCOMPLETE;
            if(scanning > 0 || pending > 0 || completed > 0) state = ScanState.SCANNING;
            if(incomplete == 0 && scanning == 0) state = ScanState.PENDING_ANALYSIS;
            if(incomplete == 0 && scanning == 0 && pending == 0) state = ScanState.COMPLETED;
            return state;
        }
    }


    @Override
    public void onFileStart(File file) {
        try {
            String[] relPath = this.toRelPath(file.getAbsolutePath());
            ScanStateTree node = populateAndRetrieve(relPath);

            node.setState(ScanState.SCANNING);

        } catch (TreePathException e) {
            System.err.println(e.getMessage());
        }
    }

    @Override
    public void onFileComplete(File file) {
        try {
            String[] relPath = this.toRelPath(file.getAbsolutePath());
            ScanStateTree node = (ScanStateTree) super.getDescendant(relPath);

            if (node.getState() != ScanState.SKIPPED) {
                node.setState(ScanState.PENDING_ANALYSIS);
            }

        } catch (TreePathException e) {
            System.err.println(e.getMessage());
        }
    }

    @Override
    public void onAnalysisReceived(File file, Utils.FileStatus status, String message) {
        try {
            String[] relPath = this.toRelPath(file.getAbsolutePath());
            ScanStateTree node = (ScanStateTree) super.getDescendant(relPath);

            node.setState(ScanState.COMPLETED);

        } catch (TreePathException e) {
            System.err.println(e.getMessage());
        }
    }

    @Override
    public void onFileSkipped(File file) {
        try {
            String[] relPath = this.toRelPath(file.getAbsolutePath());
            ScanStateTree node = (ScanStateTree) getDescendant(relPath);

            node.setState(ScanState.SKIPPED);

        }catch (TreePathException e){
            System.err.println(e.getMessage());
        }
    }

    @Override
    public void onFileFailed(File file, Exception exception) {
        try {
            String[] relPath = this.toRelPath(file.getAbsolutePath());
            ScanStateTree node = (ScanStateTree) getDescendant(relPath);

            node.setState(ScanState.FAILED);

        }catch (TreePathException e){
            System.err.println(e.getMessage());
        }
    }

    @Override
    public void onDirectoryEntered(File directory) {

    }

    @Override
    public void onDirectoryLeft(File directory) {

    }
}

