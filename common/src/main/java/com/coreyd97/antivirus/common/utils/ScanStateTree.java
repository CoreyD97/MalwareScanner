package com.coreyd97.antivirus.common.utils;

import com.coreyd97.antivirus.common.exception.TreePathException;
import com.coreyd97.antivirus.common.taskscheduler.ScanTaskFileListener;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;

public class ScanStateTree extends StateTree implements ScanTaskFileListener {
    private enum ScanState{
        INCOMPLETE(0), SCANNING(1), PENDING_ANALYSIS(2), COMPLETED(3), SKIPPED(-1);
        public int priority;
        ScanState(int priority){
            this.priority = priority;
        }
    }

    ScanState state;
    boolean childrenPopulated;

    HashMap<ScanState, Integer> childStates;


    private ScanStateTree(String nodeName, ScanStateTree parent, boolean isLeaf){
        super(nodeName, parent, isLeaf);
        this.state = ScanState.INCOMPLETE;

        if(!this.isLeaf){
            childStates = new HashMap<>();
            childStates.put(ScanState.INCOMPLETE, 0);
            childStates.put(ScanState.SCANNING, 0);
            childStates.put(ScanState.PENDING_ANALYSIS, 0);
            childStates.put(ScanState.COMPLETED, 0);
            childStates.put(ScanState.SKIPPED, 0);
        }
    }

    public static ScanStateTree createTree(File file){
        String nodeName = file.getAbsolutePath();
        boolean isLeaf = !file.isDirectory();

        return new ScanStateTree(nodeName, null, isLeaf);
    }

    public ScanStateTree getParent() {
        return (ScanStateTree) parent;
    }

    public ScanStateTree getChild(String childName) {
        return (ScanStateTree) super.getChild(childName);
    }

    @Override
    protected int populateChildren() {
        File directory = new File(this.getPath());

        if(!directory.isDirectory()) return 0;

        if(this.isLeafNode()){
            this.children = new HashMap<>();
        }

        int populatedChildren = 0;

        File[] childFiles = directory.listFiles();
        if(childFiles != null){
            for (File child : childFiles) {
                try {
                    if(FileUtils.isSymlink(child)) continue;
                } catch (IOException e) {}

                StateTree added = this.addChild(child.getName(), child.isFile());
                if(added != null) populatedChildren++;

            }
            incrementStateCount(ScanState.INCOMPLETE, populatedChildren);
        }
        this.childrenPopulated = true;

        return populatedChildren;
    }

    public ScanState getState(String nodePath) throws TreePathException{
        return this.getState(this.toRelPath(nodePath));
    }

    private ScanState getState(String[] relPath) throws TreePathException {
        if(relPath.length == 0){
            return this.getState();
        }
        if(this.isLeafNode()){
            throw new TreePathException("Cannot get descendants of a file. " + this.getPath());
        }else{
            ScanStateTree child = this.getChild(relPath[0]);
            if(child == null){
                return this.getState();
            }

            return child.getState(Arrays.copyOfRange(relPath, 1, relPath.length));
        }
    }

    private void setState(ScanState state) {
        if(this.state != state) {
            ScanState oldState = this.state;
            this.state = state;

            //If we've completed entire directory remove children.
            if(this.state == ScanState.COMPLETED && !this.isLeaf){
                this.children = null;
            }

            //Update parent too if needed. (Bubble up)
            if(this.parent != null) {
                ((ScanStateTree) this.parent).decrementStateCount(oldState, 1);
                ((ScanStateTree) this.parent).incrementStateCount(state, 1);
                ((ScanStateTree) this.parent).setState(((ScanStateTree) this.parent).getState());
            }
        }
    }

    protected ScanStateTree populateAndRetrieve(String[] relPath) throws TreePathException {
        if(!this.childrenPopulated){
            this.populateChildren();
        }

        if(relPath.length == 0){
            return this;
        }else {
            if(this.isLeaf) throw new TreePathException(this.getPath() + " does not have a child: " + relPath[0] + " it's not a directory!");
            ScanStateTree child = (ScanStateTree) this.children.get(relPath[0]);
            if(child == null){
                throw new TreePathException(this.getPath() + " does not have a child: " + relPath[0]);
            }else{
                return child.populateAndRetrieve(Arrays.copyOfRange(relPath, 1, relPath.length));
            }
        }
    }

    protected void incrementStateCount(ScanState state, int count){
        synchronized (this.childStates){
            this.childStates.put(state, this.childStates.get(state) + count);
        }
    }

    protected void decrementStateCount(ScanState state, int count){
        synchronized (this.childStates){
            this.childStates.put(state, this.childStates.get(state) - count);
        }
    }

    @Override
    protected StateTree createChild(String childName, boolean isLeaf) {
        return new ScanStateTree(childName, this, isLeaf);
    }

    public ScanState getState(){
        if(this.isLeaf){
           return state;
        }else{
            int incomplete = this.childStates.get(ScanState.INCOMPLETE);
            int scanning = this.childStates.get(ScanState.SCANNING);
            int pending = this.childStates.get(ScanState.PENDING_ANALYSIS);
            int completed = this.childStates.get(ScanState.COMPLETED);
            int skipped = this.childStates.get(ScanState.SKIPPED);
            ScanState state = ScanState.COMPLETED;
            if(pending > 0) state = ScanState.PENDING_ANALYSIS;
            if(scanning > 0) state = ScanState.SCANNING;
            if(scanning == 0 && pending == 0 && completed == 0) state = ScanState.INCOMPLETE;
            if(this.children != null && skipped == this.children.size()) state = ScanState.SKIPPED;
            return state;
        }
    }

    @Override
    public void onDirectoryEntered(File directory) {
//        try {
//            directoryEntered(directory.getAbsolutePath());
//        }catch (TreePathException e){}
    }

    @Override
    public void onScanStarted(File file){
        try {
            String[] relPath = this.toRelPath(file.getAbsolutePath());
            ScanStateTree node = populateAndRetrieve(relPath);

            node.setState(ScanState.SCANNING);

        } catch (TreePathException e) {
            System.err.println(e.getMessage());
        }
    }

    @Override
    public void onScanCompleted(File file) {
        try {
            String[] relPath = this.toRelPath(file.getAbsolutePath());
            ScanStateTree node = (ScanStateTree) super.getDescendant(relPath);

            if(node.getState() != ScanState.SKIPPED) {
                node.setState(ScanState.PENDING_ANALYSIS);
            }

        } catch (TreePathException e) {
            System.err.println(e.getMessage());
        }
    }

    @Override
    public void onAnalysisReceived(File file, Utils.FileStatus status) {
        try {
            String[] relPath = this.toRelPath(file.getAbsolutePath());
            ScanStateTree node = (ScanStateTree) super.getDescendant(relPath);

            node.setState(ScanState.COMPLETED);

        } catch (TreePathException e) {
            System.err.println(e.getMessage());
        }
    }

    @Override
    public void onDirectoryLeft(File directory) {
//        try {
//            directoryLeft(directory.getAbsolutePath());
//        }catch (TreePathException e){}
    }

    @Override
    public void onFileSkipped(File file, String cause) {
        try {
            String[] relPath = this.toRelPath(file.getAbsolutePath());
            ScanStateTree node = (ScanStateTree) getDescendant(relPath);

            node.setState(ScanState.SKIPPED);

        }catch (TreePathException e){
            System.err.println(e.getMessage());
        }
    }

}

