package com.coreyd97.antivirus.common.utils;

import com.coreyd97.antivirus.common.exception.TreePathException;
import com.coreyd97.antivirus.common.taskscheduler.ScanTaskFileListener;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public class ScanStateTree extends StateTree implements ScanTaskFileListener {
    private enum ScanState{
        COMPLETED(0), SCANNING(2), PENDING_ANALYSIS(1), INCOMPLETE(3);
        public int priority;
        ScanState(int priority){
            this.priority = priority;
        }
    }

    ScanState state;
    boolean childrenPopulated;
    int childPendingAnalysisCount = 0;
    int childPendingScanCount = 0;

    private ScanStateTree(String nodeName, ScanStateTree parent, boolean isLeaf){
        super(nodeName, parent, isLeaf);
        this.state = ScanState.INCOMPLETE;
    }

    public static ScanStateTree createTree(File file){
        String nodeName = file.getAbsolutePath();
        boolean isLeaf = !file.isDirectory();

        return new ScanStateTree(nodeName, null, isLeaf);
    }

    public ScanStateTree getParent() {
        return (ScanStateTree) parent;
    }

    public ScanStateTree getChild(String childName) {
        return (ScanStateTree) super.getChild(childName);
    }

    public void directoryEntered(String nodePath) throws TreePathException {
        directoryEntered(this.toRelPath(nodePath));
    }

    @Override
    protected int populateChildren() {
        File directory = new File(this.getPath());

        if(!directory.isDirectory()) return 0;

        if(this.isLeafNode()){
            this.children = new HashMap<>();
        }

        int populatedChildren = 0;

        File[] childFiles = directory.listFiles();
        if(childFiles != null){
            int childFilesCount = 0;
            for (File child : childFiles) {
                try {
                    if(FileUtils.isSymlink(child)) continue;
                } catch (IOException e) {}

                StateTree added = this.addChild(child.getName());
                if(added != null) populatedChildren++;

                if(child.isFile()) childFilesCount++;
            }
            this.childPendingScanCount += childFilesCount;
        }
        this.childrenPopulated = true;

        return populatedChildren;
    }

    private void directoryEntered(String[] relPath) throws TreePathException {
        if(isLeafNode()){
            this.children = new HashMap<>();
        }
        if(!childrenPopulated){
            populateChildren();
        }

        if(relPath.length == 0) return;

        if(getChild(relPath[0]) == null){
            //Child does not exist
            throw new TreePathException("Nonexistent child " + relPath[0] + " at " + this.getPath());
        }else{
            getChild(relPath[0]).directoryEntered(Arrays.copyOfRange(relPath, 1, relPath.length));
        }
    }

    public void directoryLeft(String nodePath) throws TreePathException {
        ScanStateTree descendant = (ScanStateTree) super.getDescendant(this.toRelPath(nodePath));
        descendant.simplify();
    }


    /**
     * Simplifies tree bubbling up if required
     * @throws TreePathException
     */
    private void simplify() throws TreePathException {
        if(this.isLeafNode()) {
            ((ScanStateTree) this.parent).simplify();
            return;
        }
        boolean allComplete = true;
        for(StateTree child : this.children.values()){
            if(allComplete) allComplete = ((ScanStateTree) child).state == ScanState.COMPLETED;
        }

        if(allComplete){
            this.state = ScanState.COMPLETED;
            //Remove all parent links to allow GC to work
            for (StateTree tree : this.children.values()) {
                tree.parent = null;
            }
            this.children.clear();
            if(this.parent != null) {
                ((ScanStateTree) this.parent).simplify();
            }
        }
    }

    public ScanState getState() {
        if(this.childPendingScanCount > 0) return ScanState.SCANNING;
        if(this.childPendingAnalysisCount > 0) return ScanState.PENDING_ANALYSIS;
        //We might not have any child files pending scanning//analysis but child directories may do!
        if(!this.isLeafNode() && this.children.size() > 0) {
            ScanState inferredState = ScanState.INCOMPLETE;
            for (StateTree childTree : this.children.values()) {
                ScanState childState = ((ScanStateTree) childTree).getState();
                if(childState.priority < inferredState.priority)
                    inferredState = childState;
                //We've reached highest priority. May as well return now!
                if(inferredState.priority == 3) return inferredState;
            }
            return inferredState;
        }
        return this.state;
    }

    public ScanState getState(String nodePath) throws TreePathException{
        return this.getState(this.toRelPath(nodePath));
    }

    private ScanState getState(String[] relPath) throws TreePathException {
        if(relPath.length == 0){
            return this.getState();
        }
        if(this.isLeafNode()){
            throw new TreePathException("Cannot get descendants of a file. " + this.getPath());
        }else{
            if(this.state == ScanState.COMPLETED) return this.state;
            ScanStateTree child = this.getChild(relPath[0]);
            if(child == null){
                return this.getState();
//                throw new TreePathException(this.getPath() + " does not have a child " + relPath[0]);
            }

            return child.getState(Arrays.copyOfRange(relPath, 1, relPath.length));
        }
    }


    @Override
    protected StateTree createChild(String childName) {
        return new ScanStateTree(childName, this, true);
    }

    private void setState(ScanState state) {
        this.state = state;
    }

    @Override
    public void onDirectoryEntered(File directory) {
        try {
            directoryEntered(directory.getAbsolutePath());
        }catch (TreePathException e){}
    }

    @Override
    public void onFileScanned(File file) {
        try {
            String[] relPath = this.toRelPath(file.getAbsolutePath());
            ScanStateTree fileNode = (ScanStateTree) super.getNearestDescendant(relPath);
            if(!fileNode.getPath().equals(file.getAbsolutePath())){
                fileNode.directoryEntered(Arrays.copyOfRange(relPath, 0, relPath.length-1));
                fileNode = (ScanStateTree) super.getDescendant(relPath);
            }

            fileNode.setState(ScanState.PENDING_ANALYSIS);
            synchronized (fileNode.getParent()) {
                fileNode.getParent().childPendingScanCount--;
                fileNode.getParent().childPendingAnalysisCount++;
            }
        } catch (TreePathException e) {
            System.err.println("Could not convert path to relative path " + file.getAbsolutePath());
        }
    }

    @Override
    public void onAnalysisReceived(File file, Utils.FileStatus status) {
        try {
            ScanStateTree fileNode = (ScanStateTree) super.getDescendant(this.toRelPath(file.getAbsolutePath()));
            fileNode.setState(ScanState.COMPLETED);
            synchronized (fileNode.getParent()) {
                fileNode.getParent().childPendingAnalysisCount--;
            }
            if(fileNode.getParent().childPendingAnalysisCount == 0){
                fileNode.getParent().simplify();
            }
        } catch (TreePathException e) {
            System.err.println("Could not convert path to relative path " + file.getAbsolutePath());
        }
    }

    @Override
    public void onDirectoryLeft(File directory) {
        try {
            directoryLeft(directory.getAbsolutePath());
        }catch (TreePathException e){}
    }

}

