package com.coreyd97.antivirus.common.utils;

import com.coreyd97.antivirus.common.exception.TreePathException;
import com.coreyd97.antivirus.common.taskscheduler.ScanTaskFileListener;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;

public class ScanStateTree implements ScanTaskFileListener {
    private enum ScanState{
        COMPLETED(0), SCANNING(2), PENDING_ANALYSIS(1), INCOMPLETE(3);
        public int priority;
        ScanState(int priority){
            this.priority = priority;
        }
    }

    String nodeName;
    ScanState state;
    ScanStateTree parent;
    HashMap<String, ScanStateTree> children;
    boolean childrenPopulated;
    int childPendingAnalysisCount = 0;
    int childPendingScanCount = 0;

    private ScanStateTree(File file, ScanStateTree parent){
        this.parent = parent;
        this.state = ScanState.INCOMPLETE;
        if(this.parent == null){
            this.nodeName = file.getAbsolutePath();
        }else{
            this.nodeName = file.getName();
        }

        if(file.isDirectory()){
            this.children = new HashMap<>();
            try {
                directoryEntered(new String[0]);
            } catch (TreePathException e) {
                e.printStackTrace();
            }
        }
    }

    public ScanStateTree(File file){
        this(file, null);
    }

    public ScanStateTree getParent() {
        return parent;
    }

    public String getPath(){
        if(this.parent == null) return this.nodeName;
        return this.parent.getPath() + File.separator + this.nodeName;
    }

    public String[] toRelPath(String nodePath) throws TreePathException{
        String currentPath = this.getPath();
        if (!nodePath.startsWith(currentPath)) {
            throw new TreePathException("The directory entered is not part of this tree!");
        }
        if(nodePath.equals(currentPath)){
            return new String[]{};
        }
        String[] relPath = nodePath.substring(currentPath.length() + 1).split(File.separator);
        return relPath;
    }

    public void directoryEntered(String nodePath) throws TreePathException {
        directoryEntered(this.toRelPath(nodePath));
    }

    private void directoryEntered(String[] relPath) throws TreePathException {
        if(children == null){
            throw new TreePathException("The specified file is not a directory! " + this.getPath());
        }
        if(!childrenPopulated){
            //Populate its children
            File directory = new File(this.getPath());
            assert directory.isDirectory();
            File[] childFiles = directory.listFiles();
            if(childFiles != null){
                int childFilesCount = 0;
                for (File child : childFiles) {
                    try {
                        if(FileUtils.isSymlink(child)) continue;
                    } catch (IOException e) {}

                    ScanStateTree childTree = new ScanStateTree(child, this);
                    this.children.put(child.getName(), childTree);
                    if(child.isFile()) childFilesCount++;
                }
                this.childPendingScanCount = childFilesCount;
            }
            this.childrenPopulated = true;
        }
        if(relPath.length == 0) return;

        if(children.get(relPath[0]) == null){
            //Child does not exist
        }else{
            children.get(relPath[0]).directoryEntered(Arrays.copyOfRange(relPath, 1, relPath.length));
        }
    }

    public void directoryLeft(String nodePath) throws TreePathException {
        ScanStateTree descendant = getDescendant(this.toRelPath(nodePath));
        descendant.simplify();
    }

    public ScanStateTree getDescendant(String[] relPath) throws TreePathException {
        if(relPath.length == 0) return this;
        if(this.children == null){
            throw new TreePathException("Cannot get descendants of a file. " + this.getPath());
        }else{
            ScanStateTree child = this.children.get(relPath[0]);
            if(child == null){
                throw new TreePathException(this.getPath() + " does not have a child " + relPath[0]);
            }

            return child.getDescendant(Arrays.copyOfRange(relPath, 1, relPath.length));
        }
    }

    /**
     * Simplifies tree bubbling up if required
     * @throws TreePathException
     */
    private void simplify() throws TreePathException {
        if(this.children == null) return;
        boolean allComplete = true;
        for(ScanStateTree child : this.children.values()){
            if(allComplete) allComplete = child.state == ScanState.COMPLETED;
        }

        if(allComplete){
            this.state = ScanState.COMPLETED;
            //Remove all parent links to allow GC to work
            for (ScanStateTree tree : this.children.values()) {
                tree.parent = null;
            }
            this.children.clear();
            if(this.parent != null) {
                this.parent.simplify();
            }
        }
    }

    public ScanState getState() {
        if(this.childPendingScanCount > 0) return ScanState.SCANNING;
        if(this.childPendingAnalysisCount > 0) return ScanState.PENDING_ANALYSIS;
        //We might not have any child files pending scanning//analysis but child directories may do!
        if(this.children != null && this.children.size() > 0) {
            ScanState inferredState = ScanState.INCOMPLETE;
            for (ScanStateTree childTree : this.children.values()) {
                ScanState childState = childTree.getState();
                if(childState.priority < inferredState.priority)
                    inferredState = childState;
                //We've reached highest priority. May as well return now!
                if(inferredState.priority == 3) return inferredState;
            }
            return inferredState;
        }
        return this.state;
    }

    public ScanState getState(String nodePath) throws TreePathException{
        return this.getState(this.toRelPath(nodePath));
    }

    private ScanState getState(String[] relPath) throws TreePathException {
        if(relPath.length == 0){
            return this.getState();
        }
        if(this.children == null){
            throw new TreePathException("Cannot get descendants of a file. " + this.getPath());
        }else{
            if(this.state == ScanState.COMPLETED) return this.state;
            ScanStateTree child = this.children.get(relPath[0]);
            if(child == null){
                return this.getState();
//                throw new TreePathException(this.getPath() + " does not have a child " + relPath[0]);
            }

            return child.getState(Arrays.copyOfRange(relPath, 1, relPath.length));
        }
    }

    private void setState(ScanState state) {
        this.state = state;
    }

    @Override
    public void onDirectoryEntered(File directory) {
        try {
            directoryEntered(directory.getAbsolutePath());
        }catch (TreePathException e){}
    }

    @Override
    public void onFileScanned(File file) {
        try {
            String[] relPath = this.toRelPath(file.getAbsolutePath());
            ScanStateTree fileNode = this.getDescendant(relPath);
            fileNode.setState(ScanState.PENDING_ANALYSIS);
            synchronized (fileNode.getParent()) {
                fileNode.getParent().childPendingScanCount--;
                fileNode.getParent().childPendingAnalysisCount++;
            }
        } catch (TreePathException e) {
            System.err.println("Could not convert path to relative path " + file.getAbsolutePath());
            System.exit(0);
        }
    }

    @Override
    public void onAnalysisReceived(File file, Utils.FileStatus status) {
        try {
            ScanStateTree fileNode = this.getDescendant(this.toRelPath(file.getAbsolutePath()));
            fileNode.setState(ScanState.COMPLETED);
            synchronized (fileNode.getParent()) {
                fileNode.getParent().childPendingAnalysisCount--;
            }
            if(fileNode.getParent().childPendingAnalysisCount == 0){
                fileNode.getParent().simplify();
            }
        } catch (TreePathException e) {
            System.err.println("Could not convert path to relative path " + file.getAbsolutePath());
        }
    }

    @Override
    public void onDirectoryLeft(File directory) {
        try {
            directoryLeft(directory.getAbsolutePath());
        }catch (TreePathException e){}
    }

}

