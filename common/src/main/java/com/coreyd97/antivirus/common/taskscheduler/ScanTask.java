package com.coreyd97.antivirus.common.taskscheduler;

import com.coreyd97.antivirus.common.engine.ClientDetectionModule;
import com.coreyd97.antivirus.common.report.ReportHandler;
import com.coreyd97.antivirus.common.report.ReportPublisher;
import com.coreyd97.antivirus.common.report.ResultsReport;
import com.coreyd97.antivirus.common.report.ScanReport;
import com.coreyd97.antivirus.common.utils.Utils;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.UUID;
import java.util.concurrent.ExecutorService;
import java.util.logging.Logger;

public abstract class ScanTask extends Task<ResultsReport> implements ReportPublisher<ScanReport>, ThreadedTask {
    public enum ScanType{SCAN,EXPLAIN}
    enum ReportFrequency {SINGLE, BATCH, INDIVIDUAL}

    private File[] files;
    private final ArrayList<ScanTaskFileListener> taskFileListeners;
    protected ScanReport report;
    private final ClientDetectionModule detectionModule;
    protected ReportFrequency reportFrequency;
    private ReportHandler<ScanReport> reportHandler;
    private int pendingReportCount = 0;
    private final HashMap<UUID, ScanReport> pendingReports;
    private final ResultsReport combinedResults;
    private final int reportSize = 100;

    private ExecutorService executor;
    private Integer pendingThreadCount = 0;
    private final ScanType scanType;

    protected ScanTask(String taskName, File[] files, ClientDetectionModule detectionModule, ScanType scanType) {
        super(taskName);
        this.files = files;
        this.detectionModule = detectionModule;
        this.pendingReports = new HashMap<>();
        this.report = new ScanReport(detectionModule, this, scanType);
        this.combinedResults = new ResultsReport(this);
        this.taskFileListeners = new ArrayList<>();
        this.reportFrequency = ReportFrequency.BATCH;
        this.scanType = scanType;
    }

    public void setExecutorService(ExecutorService executorService) {
        this.executor = executorService;
    }

    public void setReportFrequency(ReportFrequency reportFrequency) { this.reportFrequency = reportFrequency; }

    public void setReportHandler(ReportHandler<ScanReport> reportHandler){
        this.reportHandler = reportHandler;
    }

    //Implement in subclasses to define handling of each file.
    protected abstract boolean processFile(File file);

    private void processFiles(File files[]){
        for (File file : files) {
            if(file.isDirectory()){
                try {
                    if (FileUtils.isSymlink(file)){
                        continue;
                    }
                }catch (IOException ignored){}

                File[] childFiles = file.listFiles();
                if(childFiles == null) continue;
                synchronized (this.taskFileListeners){
                    this.taskFileListeners.forEach(listener -> listener.onDirectoryEntered(file));
                }
                processFiles(childFiles);
                synchronized (this.taskFileListeners){
                    this.taskFileListeners.forEach(listener -> listener.onDirectoryLeft(file));
                }
            }else if(file.isFile()){
                //TODO add multithreading like TrainTask
                //Fill scanReport with file features
                if(this.executor != null){
                    //If we're multithreading
                    this.executor.execute(() -> {
                        synchronized (this.taskFileListeners){
                            try {
                                this.taskFileListeners.forEach(listener -> listener.onScanStarted(file));
                            }catch (Exception e){
                                e.printStackTrace();
                            }
                        }
                        boolean scanned = processFile(file);
                        if(scanned) {
                            synchronized (this.taskFileListeners) {
                                try {
                                    this.taskFileListeners.forEach(listener -> listener.onScanCompleted(file));
                                } catch (Exception e) {
                                    e.printStackTrace();
                                }
                            }
                            publishReport();
                        }else{
                            synchronized (this.taskFileListeners){
                                for (ScanTaskFileListener taskFileListener : this.taskFileListeners) {
                                    taskFileListener.onFileSkipped(file, "");
                                }
                            }
                        }
                        taskProgress();
                        synchronized (pendingThreadCount) {
                            pendingThreadCount--;
                        }
                    });
                    synchronized (pendingThreadCount) {
                        pendingThreadCount++;
                    }
                }else {
                    synchronized (this.taskFileListeners){
                        this.taskFileListeners.forEach(listener -> listener.onScanStarted(file));
                    }
                    processFile(file);
                    synchronized (this.taskFileListeners){
                        this.taskFileListeners.forEach(listener -> listener.onScanCompleted(file));
                    }
                    publishReport();
                    taskProgress();
                }
            }else{
                //Linux device file or similar.
                taskProgress();
            }
        }
    }

    private void publishReport(){
        if(this.reportHandler == null) return;
        switch (reportFrequency) {
            case INDIVIDUAL: {
                this.pendingReports.put(this.report.getUUID(), this.report);
                this.reportHandler.onReportReady(report);
                this.report = new ScanReport(this.detectionModule, this, this.scanType);
                break;
            }
            case BATCH: {
                if(this.pendingReportCount++ == this.reportSize){
                    this.pendingReports.put(this.report.getUUID(), this.report);
                    this.reportHandler.onReportReady(report);
                    this.report = new ScanReport(this.detectionModule, this, this.scanType);
                    this.pendingReportCount = 0;
                }
                break;
            }
        }
    }


    //Combine analysis from separate submitted reports into single result report.
    public void processAnalysisReport(ResultsReport resultsReport){
        if(!resultsReport.getTaskUUID().equals(this.getUUID())){
            Logger.getGlobal().warning("Results scanReport received for incorrect task!");
        }

        ArrayList<String> infectedFiles = new ArrayList<>();
        if(resultsReport.getFoundMalware().size() > 0){ //Malware detected.
            resultsReport.getFoundMalware().forEach(malwareEntry -> {
                this.combinedResults.addMalware(malwareEntry);
                infectedFiles.add(malwareEntry.getFilePath());
            });
        }

        resultsReport.getExplanations().forEach(this.combinedResults::addExplanation);

        ScanReport scanReport = this.pendingReports.remove(resultsReport.getUUID());

        scanReport.getFileFeatures().forEach(fileFeatures -> {
            String filePath = fileFeatures.getFilePath();
            Utils.FileStatus status = infectedFiles.contains(filePath) ? Utils.FileStatus.MALWARE : Utils.FileStatus.CLEAN;
            this.taskFileListeners.forEach(listener -> listener.onAnalysisReceived(new File(filePath), status));
        });
    }

    public void run() {
        taskStart(Utils.countFiles(files));
        logMessage(TaskLogListener.MessageType.INFO, "Task Started");
        processFiles(this.files);

        while(this.pendingThreadCount != 0){
            try{
                Thread.sleep(1000);
            }catch (InterruptedException ignored){}
        }

        //If we're only sending a single scanReport. Or a batch scanReport is not full. Send it now.
        if(this.reportHandler != null) {
            if (this.reportFrequency == ReportFrequency.SINGLE) {
                this.pendingReports.put(this.report.getUUID(), this.report);
                this.reportHandler.onReportReady(report);
            } else if (this.reportFrequency == ReportFrequency.BATCH && this.pendingReportCount != 0) {
                this.pendingReports.put(this.report.getUUID(), this.report);
                this.reportHandler.onReportReady(report);
            }
        }

        int pending = 0;
        while (this.pendingReports.size() > 0){
            //Waiting for pendingReports to be analysed.
            if(pending != this.pendingReports.size()) {
                logMessage(TaskLogListener.MessageType.INFO, "Waiting for " + this.pendingReports.size() + " reports to be analysed.");
                pending = this.pendingReports.size();
            }
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {}
        }

        //If all pendingReports have been analysed and collated.
        this.result = combinedResults;
        this.completed = true;
        if(this.callback != null) {
            new Thread(this.callback).start();
        }
        logMessage(TaskLogListener.MessageType.INFO, "Task Complete");
        taskComplete();
    }

    public File[] getStartFiles() {
        return files;
    }

    public void registerFileListener(ScanTaskFileListener listener){
        synchronized (this.taskFileListeners){
            this.taskFileListeners.add(listener);
        }
    }

    public void removeFileListener(ScanTaskFileListener listener){
        synchronized (this.taskFileListeners){
            this.taskFileListeners.remove(listener);
        }
    }

    public ClientDetectionModule getDetectionModule() {
        return detectionModule;
    }

    public ScanType getType() {
        return scanType;
    }
}
