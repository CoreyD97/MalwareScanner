package com.coreyd97.antivirus.common.taskscheduler;

import com.coreyd97.antivirus.common.engine.ClientDetectionModule;
import com.coreyd97.antivirus.common.report.*;
import com.coreyd97.antivirus.common.utils.Utils;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Logger;

public abstract class ScanTask extends FileSystemTask<ResultsReport> implements ReportPublisher<ScanReport>, IFileTaskListener {
    public enum ScanType{SCAN,EXPLAIN}
    enum ReportFrequency {SINGLE, BATCH, INDIVIDUAL}

    protected ScanReport report;
    private final HashMap<UUID, ScanReport> pendingReports;
    private final ResultsReport combinedResults;

    private ReportHandler<ScanReport> reportHandler;
    private final ClientDetectionModule detectionModule;
    private final ArrayList<IScanTaskListener> scanTaskListeners;

    private AtomicInteger pendingReportCount;
    private final int reportSize = 100;
    protected ReportFrequency reportFrequency;

    private final ScanType scanType;

    protected ScanTask(String taskName, File[] files, ClientDetectionModule detectionModule, ScanType scanType) {
        super(taskName, files);
        this.detectionModule = detectionModule;
        this.pendingReports = new HashMap<>();
        this.report = new ScanReport(detectionModule, this, scanType);
        this.combinedResults = new ResultsReport(this);
        this.reportFrequency = ReportFrequency.BATCH;
        this.scanType = scanType;
        this.scanTaskListeners = new ArrayList<>();
        this.pendingReportCount = new AtomicInteger();
        this.registerFileListener(this);
    }

    public void setReportFrequency(ReportFrequency reportFrequency) { this.reportFrequency = reportFrequency; }

    public void setReportHandler(ReportHandler<ScanReport> reportHandler){
        this.reportHandler = reportHandler;
    }

    private synchronized void publishReport(){
        if(this.reportHandler == null) return;
        switch (reportFrequency) {
            case INDIVIDUAL: {
                this.pendingReports.put(this.report.getUUID(), this.report);
                this.reportHandler.onReportReady(report);
                this.report = new ScanReport(this.detectionModule, this, this.scanType);
                break;
            }
            case BATCH: {
                if(this.pendingReportCount.incrementAndGet() == this.reportSize){
                    this.pendingReports.put(this.report.getUUID(), this.report);
                    this.reportHandler.onReportReady(report);
                    this.report = new ScanReport(this.detectionModule, this, this.scanType);
                    this.pendingReportCount.set(0);
                }
                break;
            }
        }
    }

    @Override
    public int getPriority() {
        return 10;
    }

    @Override
    public void onDirectoryEntered(File directory) {}
    @Override
    public void onDirectoryLeft(File directory) {}
    @Override
    public void onFileStart(File file) {}

    @Override
    public void onFileComplete(File file) {
        publishReport();
    }

    @Override
    public void onFileSkipped(File file) {}

    @Override
    public void onFileFailed(File file, Exception e) {}

    //Combine analysis from separate submitted reports into single result report.
    public void processAnalysisReport(ResultsReport resultsReport){
        if(!resultsReport.getTaskUUID().equals(this.getUUID())){
            Logger.getGlobal().warning("Results scanReport received for incorrect task!");
        }

        HashMap<String, MalwareEntry> infectedFiles = new HashMap<>();
        if(resultsReport.getFoundMalware().size() > 0){ //Malware detected.
            resultsReport.getFoundMalware().forEach(malwareEntry -> {
                this.combinedResults.addMalware(malwareEntry);
                infectedFiles.put(malwareEntry.getFilePath(), malwareEntry);
            });
        }

        resultsReport.getExplanations().forEach(this.combinedResults::addExplanation);

        ScanReport scanReport = this.pendingReports.remove(resultsReport.getUUID());

        scanReport.getFileFeatures().forEach(fileFeatures -> {
            try {
                String filePath = fileFeatures.getFilePath();
                MalwareEntry malwareEntry = infectedFiles.get(filePath);
                Utils.FileStatus status = malwareEntry == null ? Utils.FileStatus.CLEAN : Utils.FileStatus.MALWARE;
                String message = (malwareEntry == null ? "" : malwareEntry.getMessage());
                this.scanTaskListeners.forEach(listener -> listener.onAnalysisReceived(new File(filePath), status, message));
            }catch (Exception ignored){}
        });
    }


    @Override
    protected void allThreadsComplete() {
        //If we're only sending a single scanReport. Or a batch scanReport is not full. Send it now.
        if(this.reportHandler != null) {
            if (this.reportFrequency == ReportFrequency.SINGLE) {
                this.pendingReports.put(this.report.getUUID(), this.report);
                this.reportHandler.onReportReady(report);
            } else if (this.reportFrequency == ReportFrequency.BATCH && this.pendingReportCount.get() != 0) {
                this.pendingReports.put(this.report.getUUID(), this.report);
                this.reportHandler.onReportReady(report);
            }
        }

        int pending = 0;
        while (this.pendingReports.size() > 0){
            //Waiting for pendingReports to be analysed.
            if(pending != this.pendingReports.size()) {
                logMessage(TaskLogListener.MessageType.INFO, "Waiting for " + this.pendingReports.size() + " reports to be analysed.");
                pending = this.pendingReports.size();
            }
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {}
        }

        //If all pendingReports have been analysed and collated.
        this.result = combinedResults;
    }

    public ClientDetectionModule getDetectionModule() {
        return detectionModule;
    }

    public ScanType getType() {
        return scanType;
    }

    public void registerScanTaskListener(IScanTaskListener listener){
        synchronized (this.scanTaskListeners){
            this.scanTaskListeners.add(listener);
        }
    }

    public void removeScanTaskListener(IScanTaskListener listener){
        synchronized (this.scanTaskListeners){
            this.scanTaskListeners.remove(listener);
        }
    }
}
