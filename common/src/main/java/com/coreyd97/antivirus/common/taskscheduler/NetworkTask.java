package com.coreyd97.antivirus.common.taskscheduler;

import com.coreyd97.antivirus.common.network.ServerConnectionHandler;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.util.logging.Logger;

/**
 * Base class for all tasks which interact with a server
 * @param <T> The return type
 */
public abstract class NetworkTask<T> extends Task<T> {

    private final ServerConnectionHandler networkController;
    private Socket socket;
    private BufferedReader input;
    private PrintWriter output;
    protected SecretKey sessionKey;

    protected NetworkTask(String taskName, ServerConnectionHandler networkController){
        super(taskName);
        this.networkController = networkController;
    }

    /**
     * Generate a session key and complete challenge-response with server. (Validate the key is correct)
     * @throws UnauthorizedException
     * @throws IOException
     * @throws GeneralSecurityException
     * @throws DecoderException
     */
    private void auth() throws UnauthorizedException, IOException, GeneralSecurityException, DecoderException {
        SecretKey tmpKey = this.networkController.generateSessionKey();
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        byte[] key = md.digest(tmpKey.getEncoded());
        this.sessionKey = new SecretKeySpec(key, "AES");
        sendPKI(key);
        String challenge = readLine();
        send(challenge);
        if(!readLine().equals("OK")) throw new UnauthorizedException();
    }

    /**
     * Called by implementations of the class,
     * defines procedure of interacting with the server
     * @return The result
     * @throws IOException
     * @throws GeneralSecurityException
     * @throws DecoderException
     */
    protected abstract T interact() throws IOException, GeneralSecurityException, DecoderException;

    /**
     * Defines how to handle failures by the implementing class.
     * @return The result
     */
    protected abstract T onFailure();


    /**
     * Setup the input and output of the connection
     * and authorise with the server.
     */
    @Override
    public void run() {
        taskStart(1);
        try{
            socket = this.networkController.establishConnection();
            input = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            output = new PrintWriter(socket.getOutputStream(), true);
            this.auth();
            this.result = interact();
        }catch (Exception e){
            e.printStackTrace();
            Logger.getLogger("Network Task").warning(e.getMessage());
            this.result = onFailure();
        }finally {
            taskProgress();
            taskComplete();

            if(socket != null) {
                try {
                    socket.close();
                } catch (IOException ignored) {}
            }
            if(input != null) {
                try {
                    input.close();
                } catch (IOException ignored) {}
            }
            if(output != null) {
                output.close();
            }
        }
        this.completed = true;
        if(this.callback != null)
            this.callback.run();
    }

    /**
     * Send a message to the server.
     * @param msg The plaintext message
     * @throws GeneralSecurityException
     */
    protected void send(String msg) throws GeneralSecurityException {
        sendBytes(msg.getBytes());
    }

    /**
     * Send an encrypted message to the server using the current session key.
     * @param msg The plaintext message bytes.
     * @throws GeneralSecurityException
     */
    protected void sendBytes(byte[] msg) throws GeneralSecurityException {
        byte[] encrypted = this.networkController.encrypt(msg, this.sessionKey);
        this.output.println(Hex.encodeHexString(encrypted));
    }

    /**
     * Send an encrypted message to the server using their public key.
     * @param msg The plaintext message bytes to be sent.
     * @throws GeneralSecurityException
     */
    protected void sendPKI(byte[] msg) throws GeneralSecurityException {
        byte[] encrypted = this.networkController.encryptPKI(msg, this.networkController.getServerPublicKey());
        String encoded = Hex.encodeHexString(encrypted);
        this.output.println(encoded);
    }

    /**
     * Wait for and read a message from the server.
     * @return The decrypted message.
     * @throws GeneralSecurityException
     * @throws IOException
     * @throws DecoderException
     */
    protected String readLine() throws GeneralSecurityException, IOException, DecoderException {
        String msg;
        while((msg = this.input.readLine()) == null){}
        byte[] decoded = Hex.decodeHex(msg);
        return new String(this.networkController.decrypt(decoded, this.sessionKey));
    }

    /**
     * Wait for and read a message encrypted with
     * our public key from the server.
     * @return The decrypted message.
     * @throws GeneralSecurityException
     * @throws IOException
     * @throws DecoderException
     */
    protected String readLinePKI() throws GeneralSecurityException, IOException, DecoderException {
        String msg;
        while((msg = this.input.readLine()) == null){}
        byte[] decoded = Hex.decodeHex(msg);
        return new String(this.networkController.decryptPKI(decoded, this.networkController.getPrivateKey()));
    }

    public static class UnauthorizedException extends Exception {
        public UnauthorizedException(){
            super("Could not authorize with the server!");
        }
    }
}