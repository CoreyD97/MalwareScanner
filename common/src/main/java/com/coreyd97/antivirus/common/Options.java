package com.coreyd97.antivirus.common;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import java.io.*;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Map;

public class Options {
    //Key, [Value, Type]
    private Map<String, Object> preferences = null;
    private File configFile;

    public Options(File configFile){
        this.configFile = configFile;
        //Try loading existing preferences.
        if(this.configFile.exists()){
            try {
                FileReader reader = new FileReader(this.configFile);
                Gson gson = new Gson();
                preferences = gson.fromJson(reader, new TypeToken<Map<String,Object>>(){}.getType());
            } catch (FileNotFoundException e) {}
        }else{
            try {
                File dir = this.configFile.getParentFile();
                if(!dir.exists()) dir.mkdir();
                this.configFile.createNewFile();
            } catch (IOException ignored) {}
        }

        if(preferences == null){
            preferences = new HashMap<>();
        }
    }

    public void setValue(String key, Object value) {
        this.preferences.put(key, value);
        Gson gson = new Gson();
        String jsonString = gson.toJson(this.preferences, new TypeToken<Map<String,Object>>(){}.getType());
        FileWriter writer = null;
        try {
            writer = new FileWriter(this.configFile);
            writer.write(jsonString);
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (writer != null) {
                try{
                    writer.close();
                } catch (IOException e) {}
            }
        }
    }

    public <T> T getValue(String key, Class<T> asClass){
        Object item = preferences.get(key);
        if(item == null) return null;

        //Workaround for Gson parsing ints as floats
        if((asClass.equals(Integer.class) || asClass.equals(int.class) || asClass.equals(Short.class) || asClass.equals(short.class))
            && (item.getClass().equals(Double.class) || item.getClass().equals(Float.class))){
            item = ((Double) item).intValue();
        }

        if(item.getClass().equals(asClass)) return (T) item;

        try{
            T asClassItem = asClass.getConstructor(item.getClass()).newInstance(item);
            preferences.put(key, asClassItem);
            return asClassItem;
        } catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) {
            //Invalid type specified or constructor does not exist etc.
            return null;
        }
    }

    public <T> T getValue(String key, Class<T> asClass, T fallback){
        T val = getValue(key, asClass);
        if(val == null){
            setValue(key, fallback);
        }
        return (val == null ? fallback : val);
    }

}
