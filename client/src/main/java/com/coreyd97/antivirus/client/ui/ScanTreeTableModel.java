package com.coreyd97.antivirus.client.ui;

import com.coreyd97.antivirus.common.taskscheduler.ScanTask;
import com.coreyd97.antivirus.common.taskscheduler.ScanTaskFileListener;
import com.coreyd97.antivirus.common.utils.Utils;
import org.jdesktop.swingx.treetable.FileSystemModel;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;

public class ScanTreeTableModel extends FileSystemModel implements ScanTaskFileListener{

    private final ScanTask scanTask;
    private enum ScanState{IGNORED, SCANNED, PENDING}
    private final HashMap<File, ScanState> fileStates;
    private final File topLevel;

    public ScanTreeTableModel(ScanTask task){
        super(task.getStartFiles().length > 1 ? task.getStartFiles()[0].getParentFile() : task.getStartFiles()[0]);
        this.fileStates = new HashMap<>();
        if(task.getStartFiles().length > 1) {
            this.topLevel = task.getStartFiles()[0].getParentFile();
            ArrayList<File> startFiles = new ArrayList<>(Arrays.asList(task.getStartFiles()));
            for(File childFile : this.topLevel.listFiles()){
                if(!startFiles.contains(childFile)){
                    fileStates.put(childFile, ScanState.IGNORED);
                }
            }
        }else{
            this.topLevel = task.getStartFiles()[0];
        }
        this.fileStates.put(this.topLevel, ScanState.PENDING);
        this.scanTask = task;
        this.scanTask.registerFileListener(this);
    }

    public void dispose() {
        this.scanTask.removeFileListener(this);
    }

    @Override
    public void onDirectoryEntered(File directory) {
        this.fileStates.put(directory, ScanState.PENDING);
    }

    @Override
    public void onFileScanned(File file) {
        //Change status in tree
        this.fileStates.put(file, ScanState.SCANNED);
    }

    @Override
    public void onAnalysisReceived(File file, Utils.FileStatus status) {

    }

    @Override
    public void onDirectoryLeft(File directory) {
        File[] childFiles = directory.listFiles();
        if(childFiles == null) return;
        for(File child : childFiles){
            this.fileStates.remove(child);
        }
        this.fileStates.put(directory, ScanState.SCANNED);
    }

    @Override
    public int getColumnCount() {
        return 2;
    }

    @Override
    public Class<?> getColumnClass(int column) {
        if(column == 2) return Boolean.class;
        else return String.class;
    }

    @Override
    public String getColumnName(int column) {
        switch(column){
            case 0: return "File";
            case 1: return "Status";
            default: return "";
        }
    }

    @Override
    public Object getValueAt(Object node, int column) {
        if(node instanceof File) {
            switch (column) {
                case 0:
                    return ((File) node).getName();
                case 1:{
                    if(((File) node).isDirectory()) return null;
                    ScanState state = getFileStatus((File) node);
                    return state != ScanState.PENDING;
                }

            }
        }
        return null;
    }

    public ScanState getFileStatus(File file){
        File parent = file.getParentFile();
        if(parent == null || file.equals(topLevel)){
            //We're at root.
            ScanState result = fileStates.get(file);
            if(result == null) return ScanState.PENDING;
            else return result;
        }
        ScanState parentState = fileStates.get(parent);
        if(parentState == null){
            //Key does not exist, go up chain again
            return getFileStatus(parent);
        }else{
            if(parentState != ScanState.PENDING){
                return parentState;
            }else{
                ScanState state = fileStates.get(file);
                return state == null ? ScanState.PENDING : state;
            }
        }
    }

}
