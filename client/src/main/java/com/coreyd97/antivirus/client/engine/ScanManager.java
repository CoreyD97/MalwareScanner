package com.coreyd97.antivirus.client.engine;

import com.coreyd97.antivirus.client.network.ClientNetworkController;
import com.coreyd97.antivirus.client.network.GetResultsTask;
import com.coreyd97.antivirus.client.network.SubmitReportTask;
import com.coreyd97.antivirus.common.engine.ClientDetectionModule;
import com.coreyd97.antivirus.common.taskscheduler.TaskScheduler;
import com.coreyd97.antivirus.common.report.Report;
import com.coreyd97.antivirus.common.report.ReportHandler;
import com.coreyd97.antivirus.common.report.ScanReport;
import com.coreyd97.antivirus.common.taskscheduler.FileTask;
import com.coreyd97.antivirus.common.taskscheduler.Task;
import com.coreyd97.antivirus.common.taskscheduler.TaskListener;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.logging.Logger;

public class ScanManager extends Thread implements TaskListener, ReportHandler {
    private final ClientNetworkController networkController;
    private final TaskScheduler scheduler;
    private final HashMap<UUID, FileTask> activeScans;
    private final HashMap<UUID, Report> reportsPendingAnalysis;
    private final HashMap<ScanReport, Future<Boolean>> reportsPendingSubmission;


    public ScanManager(ClientNetworkController networkController, TaskScheduler taskScheduler){
        this.networkController = networkController;
        this.scheduler = taskScheduler;
        this.activeScans = new HashMap<>();
        this.reportsPendingAnalysis = new HashMap<>();
        this.reportsPendingSubmission = new HashMap<>();
    }

    public void updateScanSchedule(){
        //TODO Create and Update Scan Schedule
    }


    //Register request for a scan with the scheduler. This will be executed when scheduler is ready.
    public Future<ScanReport> requestScan(ClientDetectionModule scannerEngine, File[] files){
        FileTask task = scannerEngine.generateScanTask(files);
        task.setReportHandler(this);
        task.registerTaskListener(this);
        return scheduler.submitFutureTask(task);
    }

    //Create and return scan task ready for manual start
    public FileTask scanNow(ClientDetectionModule scannerEngine, File[] files){
        FileTask task = scannerEngine.generateScanTask(files);
        task.setReportHandler(this);
        task.registerTaskListener(this);
        scheduler.registerTask(task);
        return task;
    }

    @Override
    public void onReportReady(final Report report) {
        //Submit for analysis and register pending report
        SubmitReportTask submissionTask = new SubmitReportTask(networkController, (ScanReport) report);
        Future<Boolean> submissionFuture = scheduler.submitFutureTask(submissionTask);
        this.reportsPendingSubmission.put((ScanReport) report, submissionFuture);
    }

    public void resultsReceived(UUID uuid) {
        synchronized (this.reportsPendingAnalysis){
            this.reportsPendingAnalysis.remove(uuid);
        }
    }

    @Override
    public void onTaskStart(Task task, int steps) {
        synchronized (this.activeScans){
            this.activeScans.put(task.getUUID(), (FileTask) task);
        }
    }

    @Override
    public void onTaskStepsAdded(Task task, int steps) {}
    @Override
    public void onTaskProgress(Task task) {}

    @Override
    public void onTaskComplete(Task task) {
        synchronized (this.activeScans) {
            this.activeScans.remove(task.getUUID(), task);
        }
    }

    @Override
    public void run() {
        Future getScanResults = null;
        while(true){

            if(getScanResults == null){
               if(reportsPendingAnalysis.size() > 0){
                   UUID uuids[] = reportsPendingAnalysis.keySet().toArray(new UUID[]{});
                   GetResultsTask resultsTask = new GetResultsTask(networkController, this, uuids);
                   getScanResults = scheduler.submitFutureTask(resultsTask);
               }
            }else{
                if(getScanResults.isDone()){
                    getScanResults = null;
                }
            }

            synchronized (reportsPendingSubmission) {
                ArrayList<ScanReport> submittedScans = new ArrayList<>();
                reportsPendingSubmission.forEach((scanReport, booleanFuture) -> {
                    if (booleanFuture.isDone()) {
                        boolean result = false;
                        try {
                            result = booleanFuture.get();
                        } catch (InterruptedException | ExecutionException ignored) {
                            //Should not happen. We only get the result once the task is complete.
                        }

                        if (result) {
                            submittedScans.add(scanReport);
                            synchronized (reportsPendingAnalysis) {
                                reportsPendingAnalysis.put(scanReport.getUUID(), scanReport);
                            }
                        }else{
                            //TODO Handle reports which were not submitted!
                            Logger.getLogger("ScanManager").warning("Scan report could not be submitted!");
                        }
                    }
                });
                submittedScans.forEach(reportsPendingSubmission::remove);
                submittedScans.clear();
            }

            try {
                Thread.sleep(5000);
            } catch (InterruptedException ignored) {}
        }
    }
}
