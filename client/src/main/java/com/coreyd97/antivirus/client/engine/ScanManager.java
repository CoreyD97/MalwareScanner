package com.coreyd97.antivirus.client.engine;

import com.coreyd97.antivirus.common.engine.DetectionModule;
import com.coreyd97.antivirus.common.exception.UnknownScanModuleException;
import com.coreyd97.antivirus.common.network.ServerConnectionHandler;
import com.coreyd97.antivirus.client.network.GetResultsTask;
import com.coreyd97.antivirus.client.network.SubmitExplainTask;
import com.coreyd97.antivirus.client.network.SubmitScanReportTask;
import com.coreyd97.antivirus.common.engine.ClientDetectionModule;
import com.coreyd97.antivirus.common.report.ResultsReport;
import com.coreyd97.antivirus.common.taskscheduler.*;
import com.coreyd97.antivirus.common.report.Report;
import com.coreyd97.antivirus.common.report.ReportHandler;
import com.coreyd97.antivirus.common.report.ScanReport;
import org.reflections.Reflections;

import java.io.File;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;
import java.util.logging.Logger;

public class ScanManager extends Thread implements TaskStatusListener<ScanTask>, ReportHandler<ScanReport> {
    private final ServerConnectionHandler networkController;
    private final TaskScheduler scheduler;
    private final HashMap<String, ClientDetectionModule> scannerEngines;

    private final HashMap<UUID, ScanTask> activeScans;
    private final HashSet<UUID> reportsPendingAnalysis;
    private final HashMap<ScanReport, Boolean> reportsFailedSubmission;
    private boolean isGettingResults = false;
    private GetResultsTask resultsTask;


    public ScanManager(ServerConnectionHandler networkController, TaskScheduler taskScheduler){
        this.networkController = networkController;
        this.scheduler = taskScheduler;
        this.activeScans = new HashMap<>();
        this.reportsPendingAnalysis = new HashSet<>();
        this.reportsFailedSubmission = new HashMap<>();
        this.scannerEngines = new HashMap<>();

        //Use java reflection to load detection engines from package.
        //Allows "magic" loading of new modules without the need to hardcode.
        Reflections reflections = new Reflections("com.coreyd97.antivirus.client.engine");
        Set<Class<? extends ClientDetectionModule>> scannerEngines = reflections.getSubTypesOf(ClientDetectionModule.class);
        for (Class<? extends ClientDetectionModule> scannerEngine : scannerEngines) {
            if(Modifier.isAbstract(scannerEngine.getModifiers())) continue;
            String name; //Try to get engine name defined in class. Otherwise use file name.
            try {
                Field f = scannerEngine.getField("engineName");
                name = (String) f.get(null);
            } catch (NoSuchFieldException | IllegalAccessException e) {
                name = scannerEngine.getName();
            }
            try {
                ClientDetectionModule instance = scannerEngine.getConstructor().newInstance();
                this.scannerEngines.put(name, instance);
            } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {
                Logger.getAnonymousLogger().warning("Could not create instance of detection module \"" + name + "\"");
            }
        }
    }

    //Register request for a scan with the scheduler. This will be executed when scheduler is ready.
    public ScanTask requestScan(String engineName, File[] files) throws UnknownScanModuleException {
        ClientDetectionModule module = this.scannerEngines.get(engineName);
        if(module == null) throw new UnknownScanModuleException("No scan module found with name " + engineName);
        else{
            return requestScan(module, files);
        }
    }

    public ScanTask requestScan(ClientDetectionModule scannerEngine, File[] files){
        ScanTask task = scannerEngine.generateScanTask(files);
        task.setReportHandler(this);
        task.registerStatusListener(this);
        scheduler.submit(task);
        return task;
    }


    //Register request for an explanation with the scheduler. This will be executed when scheduler is ready.
    public ScanTask requestExplanation(String engineName, File[] files) throws UnknownScanModuleException {
        ClientDetectionModule module = this.scannerEngines.get(engineName);
        if(module == null) throw new UnknownScanModuleException("No scan module found with name " + engineName);
        else{
            return requestExplanation(module, files);
        }
    }
    public ScanTask requestExplanation(ClientDetectionModule scannerEngine, File[] files){
        ScanTask task = scannerEngine.generateExplainTask(files);
        task.setReportHandler(this);
        task.registerStatusListener(this);
        scheduler.submit(task);
        return task;
    }

    @Override
    public void onReportReady(final ScanReport report) {
        NetworkTask<Boolean> submissionTask;
        if(report.getType() == ScanTask.ScanType.SCAN) {
            //Submit for analysis and register pending scanReport
            submissionTask = new SubmitScanReportTask(networkController, report);
        }else{
            submissionTask = new SubmitExplainTask(networkController, report);
        }

        submissionTask.setCallback(new Runnable() {
            @Override
            public void run() {
                if (submissionTask.getResult()) {
                    synchronized (reportsPendingAnalysis) {
                        reportsPendingAnalysis.add(report.getUUID());
                    }
                    ScanTask task = activeScans.get(report.getTaskUUID());
                    if (task != null) {
                        task.logMessage(TaskLogListener.MessageType.INFO,
                                "Scan report was submitted for analysis.");
                    }
                } else {
                    synchronized (reportsFailedSubmission) {
                        reportsFailedSubmission.put(report, false);
                        ScanTask task = activeScans.get(report.getTaskUUID());
                        if (task != null) {
                            task.logMessage(TaskLogListener.MessageType.ERROR,
                                    "Could not submit scan task for analysis. Periodically retrying until success.");
                        }
                    }
                }
            }
        });
        scheduler.submit(submissionTask);
    }

    @Override
    public void onTaskStart(ScanTask task, int steps) {
        synchronized (this.activeScans){
            //Create new results scanReport to combine individual scan scanReport results.
            this.activeScans.put(task.getUUID(), task);
        }
    }

    @Override
    public void onTaskStepsAdded(ScanTask task, int steps) {}
    @Override
    public void onTaskProgress(ScanTask task) {}

    @Override
    public void onTaskComplete(ScanTask task) {
        synchronized (this.activeScans) {
            if(this.activeScans.remove(task.getUUID()) != null){
                //Scan complete and results returned.
            }
        }
    }

    @Override
    public void onTaskException(ScanTask task, Throwable throwable) {

    }

    @Override
    public void run() {
        while(true){
            synchronized (this.reportsFailedSubmission) {
                this.reportsFailedSubmission.forEach((scanReport, isRetrying) -> {
                    if(!isRetrying){ //If we've not currently got a task to retry submission
                        SubmitScanReportTask submitTask = new SubmitScanReportTask(networkController, scanReport);
                        submitTask.setCallback(() -> {
                            if(submitTask.getResult()){ //If the submission was a success.
                                ScanTask task = this.activeScans.get(scanReport.getTaskUUID());
                                if(task != null){ //Log that we've finally submitted the report for analysis.
                                    task.logMessage(TaskLogListener.MessageType.INFO, "Delayed scan report was finally submitted.");
                                }
                                synchronized (this.reportsFailedSubmission){
                                    this.reportsFailedSubmission.remove(scanReport);
                                }
                                synchronized (reportsPendingAnalysis) {
                                    reportsPendingAnalysis.add(scanReport.getUUID());
                                }
                            }else{ //Submission failed, mark as requiring reattempt.
                                synchronized (this.reportsFailedSubmission){
                                    this.reportsFailedSubmission.put(scanReport, false);
                                }
                            }
                        });
                        synchronized (this.reportsFailedSubmission) {
                            this.reportsFailedSubmission.put(scanReport, true);
                        }
                        scheduler.execute(submitTask);
                    }
                });
            }

            if(!isGettingResults && reportsPendingAnalysis.size() > 0){
                UUID uuids[] = reportsPendingAnalysis.toArray(new UUID[]{});
                resultsTask = new GetResultsTask(networkController, uuids);
                resultsTask.setReportHandler(new ReportHandler() {
                    @Override
                    public void onReportReady(Report report) {
                        ScanTask scanTask = ScanManager.this.activeScans.get(((ResultsReport) report).getTaskUUID());
                        if(scanTask != null){
                            scanTask.processAnalysisReport((ResultsReport) report);
                        }else{
                            //TODO Handle scanReport for unknown ScanTask
                        }
                        ScanManager.this.reportsPendingAnalysis.remove(report.getUUID());
                    }
                });
                resultsTask.setCallback(new Runnable() {
                    @Override
                    public void run() {
                        ScanManager.this.isGettingResults = false;
                    }
                });
                isGettingResults = true;
                scheduler.execute(resultsTask);
            }

            try {
                Thread.sleep(5000);
            } catch (InterruptedException ignored) {}
        }
    }
}
