package com.coreyd97.c45;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.Callable;

public class FeatureEntropy implements Callable {
    public Feature feature;
    String classificationA;
    List<DataElement> elements;

    public double totalEntropy;

    public double entropyGain;
    public double splitValue;

    public FeatureEntropy(Feature feature, List<DataElement> elements, Double totalEntropy, String classificationA){
        this.feature = feature;
        this.classificationA = classificationA;
        this.elements = elements;
        this.totalEntropy = totalEntropy;
        this.entropyGain = Double.MIN_VALUE;
        this.splitValue = Double.MIN_VALUE;
    }

    public static void calculateEntropy(FeatureEntropy featureEntropy){
        if(featureEntropy.elements.isEmpty()){
            featureEntropy.entropyGain = 0.0;
            return;
        }
        if(featureEntropy.feature.isCategoric){
            featureEntropy.entropyGain = featureEntropy.totalEntropy
                    - C45.featureEntropy(featureEntropy.elements, featureEntropy.feature, featureEntropy.classificationA);
        }else{
            ArrayList<Double> featureValues = new ArrayList<>();
            ArrayList<Double> splitPoints = new ArrayList<>();
            for (DataElement element : featureEntropy.elements) {
                featureValues.add(Double.parseDouble(element.features.get(featureEntropy.feature.name)));
            }
            Collections.sort(featureValues);
            for (int i = 0; i < featureValues.size()-1; i++) {
                splitPoints.add((featureValues.get(i) + featureValues.get(i+1))/2);
            }

            for (Double splitPoint : splitPoints) {
                double gain = C45.calculateEntropy(featureEntropy.elements, featureEntropy.classificationA)
                        - C45.featureEntropy(featureEntropy.elements, featureEntropy.feature, splitPoint, featureEntropy.classificationA);
                if(gain > featureEntropy.entropyGain){
                    featureEntropy.entropyGain = gain;
                    featureEntropy.splitValue = splitPoint;
                }
            }
        }
    }

    @Override
    public FeatureEntropy call() throws Exception {
        FeatureEntropy.calculateEntropy(this);
        return this;
    }
}
